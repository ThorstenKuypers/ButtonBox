
simDashECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e76  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00000e76  00000f0a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000062  00800076  00800076  00000f20  2**0
                  ALLOC
  3 .debug_aranges 00000118  00000000  00000000  00000f20  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000064d  00000000  00000000  00001038  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000d83  00000000  00000000  00001685  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000583  00000000  00000000  00002408  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000015b9  00000000  00000000  0000298b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001b0  00000000  00000000  00003f44  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000037b  00000000  00000000  000040f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000001ce  00000000  00000000  0000446f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macinfo 0001560f  00000000  00000000  0000463d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000158  00000000  00000000  00019c4c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	63 c0       	rjmp	.+198    	; 0xc8 <__ctors_end>
   2:	24 c2       	rjmp	.+1096   	; 0x44c <__vector_1>
   4:	7c c0       	rjmp	.+248    	; 0xfe <__bad_interrupt>
   6:	46 c1       	rjmp	.+652    	; 0x294 <__vector_3>
   8:	7a c0       	rjmp	.+244    	; 0xfe <__bad_interrupt>
   a:	79 c0       	rjmp	.+242    	; 0xfe <__bad_interrupt>
   c:	78 c0       	rjmp	.+240    	; 0xfe <__bad_interrupt>
   e:	77 c0       	rjmp	.+238    	; 0xfe <__bad_interrupt>
  10:	62 c1       	rjmp	.+708    	; 0x2d6 <__vector_8>
  12:	75 c0       	rjmp	.+234    	; 0xfe <__bad_interrupt>
  14:	74 c0       	rjmp	.+232    	; 0xfe <__bad_interrupt>
  16:	ba c0       	rjmp	.+372    	; 0x18c <__vector_11>
  18:	ee c0       	rjmp	.+476    	; 0x1f6 <__vector_12>
  1a:	e3 c0       	rjmp	.+454    	; 0x1e2 <__vector_13>
  1c:	70 c0       	rjmp	.+224    	; 0xfe <__bad_interrupt>
  1e:	6f c0       	rjmp	.+222    	; 0xfe <__bad_interrupt>
  20:	6e c0       	rjmp	.+220    	; 0xfe <__bad_interrupt>
  22:	bc c6       	rjmp	.+3448   	; 0xd9c <__vector_17>
  24:	6c c0       	rjmp	.+216    	; 0xfe <__bad_interrupt>
  26:	e3 c6       	rjmp	.+3526   	; 0xdee <__vector_17+0x52>
  28:	cd c6       	rjmp	.+3482   	; 0xdc4 <__vector_17+0x28>
  2a:	cc c6       	rjmp	.+3480   	; 0xdc4 <__vector_17+0x28>
  2c:	cb c6       	rjmp	.+3478   	; 0xdc4 <__vector_17+0x28>
  2e:	ca c6       	rjmp	.+3476   	; 0xdc4 <__vector_17+0x28>
  30:	c9 c6       	rjmp	.+3474   	; 0xdc4 <__vector_17+0x28>
  32:	c8 c6       	rjmp	.+3472   	; 0xdc4 <__vector_17+0x28>
  34:	c7 c6       	rjmp	.+3470   	; 0xdc4 <__vector_17+0x28>
  36:	db c6       	rjmp	.+3510   	; 0xdee <__vector_17+0x52>
  38:	c5 c6       	rjmp	.+3466   	; 0xdc4 <__vector_17+0x28>
  3a:	c4 c6       	rjmp	.+3464   	; 0xdc4 <__vector_17+0x28>
  3c:	c3 c6       	rjmp	.+3462   	; 0xdc4 <__vector_17+0x28>
  3e:	c2 c6       	rjmp	.+3460   	; 0xdc4 <__vector_17+0x28>
  40:	c1 c6       	rjmp	.+3458   	; 0xdc4 <__vector_17+0x28>
  42:	c0 c6       	rjmp	.+3456   	; 0xdc4 <__vector_17+0x28>
  44:	bf c6       	rjmp	.+3454   	; 0xdc4 <__vector_17+0x28>
  46:	d5 c6       	rjmp	.+3498   	; 0xdf2 <__vector_17+0x56>
  48:	bd c6       	rjmp	.+3450   	; 0xdc4 <__vector_17+0x28>
  4a:	bc c6       	rjmp	.+3448   	; 0xdc4 <__vector_17+0x28>
  4c:	bb c6       	rjmp	.+3446   	; 0xdc4 <__vector_17+0x28>
  4e:	ba c6       	rjmp	.+3444   	; 0xdc4 <__vector_17+0x28>
  50:	b9 c6       	rjmp	.+3442   	; 0xdc4 <__vector_17+0x28>
  52:	b8 c6       	rjmp	.+3440   	; 0xdc4 <__vector_17+0x28>
  54:	b7 c6       	rjmp	.+3438   	; 0xdc4 <__vector_17+0x28>
  56:	b6 c6       	rjmp	.+3436   	; 0xdc4 <__vector_17+0x28>
  58:	b5 c6       	rjmp	.+3434   	; 0xdc4 <__vector_17+0x28>
  5a:	b4 c6       	rjmp	.+3432   	; 0xdc4 <__vector_17+0x28>
  5c:	b3 c6       	rjmp	.+3430   	; 0xdc4 <__vector_17+0x28>
  5e:	b2 c6       	rjmp	.+3428   	; 0xdc4 <__vector_17+0x28>
  60:	b1 c6       	rjmp	.+3426   	; 0xdc4 <__vector_17+0x28>
  62:	b0 c6       	rjmp	.+3424   	; 0xdc4 <__vector_17+0x28>
  64:	af c6       	rjmp	.+3422   	; 0xdc4 <__vector_17+0x28>
  66:	c5 c6       	rjmp	.+3466   	; 0xdf2 <__vector_17+0x56>
  68:	ad c6       	rjmp	.+3418   	; 0xdc4 <__vector_17+0x28>
  6a:	ac c6       	rjmp	.+3416   	; 0xdc4 <__vector_17+0x28>
  6c:	ab c6       	rjmp	.+3414   	; 0xdc4 <__vector_17+0x28>
  6e:	aa c6       	rjmp	.+3412   	; 0xdc4 <__vector_17+0x28>
  70:	a9 c6       	rjmp	.+3410   	; 0xdc4 <__vector_17+0x28>
  72:	a8 c6       	rjmp	.+3408   	; 0xdc4 <__vector_17+0x28>
  74:	a7 c6       	rjmp	.+3406   	; 0xdc4 <__vector_17+0x28>
  76:	a6 c6       	rjmp	.+3404   	; 0xdc4 <__vector_17+0x28>
  78:	a5 c6       	rjmp	.+3402   	; 0xdc4 <__vector_17+0x28>
  7a:	a4 c6       	rjmp	.+3400   	; 0xdc4 <__vector_17+0x28>
  7c:	a3 c6       	rjmp	.+3398   	; 0xdc4 <__vector_17+0x28>
  7e:	a2 c6       	rjmp	.+3396   	; 0xdc4 <__vector_17+0x28>
  80:	a1 c6       	rjmp	.+3394   	; 0xdc4 <__vector_17+0x28>
  82:	a0 c6       	rjmp	.+3392   	; 0xdc4 <__vector_17+0x28>
  84:	9f c6       	rjmp	.+3390   	; 0xdc4 <__vector_17+0x28>
  86:	d6 c6       	rjmp	.+3500   	; 0xe34 <__vector_17+0x98>
  88:	9d c6       	rjmp	.+3386   	; 0xdc4 <__vector_17+0x28>
  8a:	9c c6       	rjmp	.+3384   	; 0xdc4 <__vector_17+0x28>
  8c:	9b c6       	rjmp	.+3382   	; 0xdc4 <__vector_17+0x28>
  8e:	9a c6       	rjmp	.+3380   	; 0xdc4 <__vector_17+0x28>
  90:	99 c6       	rjmp	.+3378   	; 0xdc4 <__vector_17+0x28>
  92:	98 c6       	rjmp	.+3376   	; 0xdc4 <__vector_17+0x28>
  94:	97 c6       	rjmp	.+3374   	; 0xdc4 <__vector_17+0x28>
  96:	e7 c6       	rjmp	.+3534   	; 0xe66 <__vector_17+0xca>
  98:	95 c6       	rjmp	.+3370   	; 0xdc4 <__vector_17+0x28>
  9a:	94 c6       	rjmp	.+3368   	; 0xdc4 <__vector_17+0x28>
  9c:	93 c6       	rjmp	.+3366   	; 0xdc4 <__vector_17+0x28>
  9e:	92 c6       	rjmp	.+3364   	; 0xdc4 <__vector_17+0x28>
  a0:	91 c6       	rjmp	.+3362   	; 0xdc4 <__vector_17+0x28>
  a2:	90 c6       	rjmp	.+3360   	; 0xdc4 <__vector_17+0x28>
  a4:	8f c6       	rjmp	.+3358   	; 0xdc4 <__vector_17+0x28>
  a6:	8e c6       	rjmp	.+3356   	; 0xdc4 <__vector_17+0x28>
  a8:	8d c6       	rjmp	.+3354   	; 0xdc4 <__vector_17+0x28>
  aa:	8c c6       	rjmp	.+3352   	; 0xdc4 <__vector_17+0x28>
  ac:	8b c6       	rjmp	.+3350   	; 0xdc4 <__vector_17+0x28>
  ae:	8a c6       	rjmp	.+3348   	; 0xdc4 <__vector_17+0x28>
  b0:	89 c6       	rjmp	.+3346   	; 0xdc4 <__vector_17+0x28>
  b2:	88 c6       	rjmp	.+3344   	; 0xdc4 <__vector_17+0x28>
  b4:	87 c6       	rjmp	.+3342   	; 0xdc4 <__vector_17+0x28>
  b6:	c1 c6       	rjmp	.+3458   	; 0xe3a <__vector_17+0x9e>
  b8:	85 c6       	rjmp	.+3338   	; 0xdc4 <__vector_17+0x28>
  ba:	84 c6       	rjmp	.+3336   	; 0xdc4 <__vector_17+0x28>
  bc:	83 c6       	rjmp	.+3334   	; 0xdc4 <__vector_17+0x28>
  be:	82 c6       	rjmp	.+3332   	; 0xdc4 <__vector_17+0x28>
  c0:	81 c6       	rjmp	.+3330   	; 0xdc4 <__vector_17+0x28>
  c2:	80 c6       	rjmp	.+3328   	; 0xdc4 <__vector_17+0x28>
  c4:	7f c6       	rjmp	.+3326   	; 0xdc4 <__vector_17+0x28>
  c6:	a7 c6       	rjmp	.+3406   	; 0xe16 <__vector_17+0x7a>

000000c8 <__ctors_end>:
  c8:	11 24       	eor	r1, r1
  ca:	1f be       	out	0x3f, r1	; 63
  cc:	cf e5       	ldi	r28, 0x5F	; 95
  ce:	d4 e0       	ldi	r29, 0x04	; 4
  d0:	de bf       	out	0x3e, r29	; 62
  d2:	cd bf       	out	0x3d, r28	; 61

000000d4 <__do_copy_data>:
  d4:	10 e0       	ldi	r17, 0x00	; 0
  d6:	a0 e6       	ldi	r26, 0x60	; 96
  d8:	b0 e0       	ldi	r27, 0x00	; 0
  da:	e6 e7       	ldi	r30, 0x76	; 118
  dc:	fe e0       	ldi	r31, 0x0E	; 14
  de:	02 c0       	rjmp	.+4      	; 0xe4 <.do_copy_data_start>

000000e0 <.do_copy_data_loop>:
  e0:	05 90       	lpm	r0, Z+
  e2:	0d 92       	st	X+, r0

000000e4 <.do_copy_data_start>:
  e4:	a6 37       	cpi	r26, 0x76	; 118
  e6:	b1 07       	cpc	r27, r17
  e8:	d9 f7       	brne	.-10     	; 0xe0 <.do_copy_data_loop>

000000ea <__do_clear_bss>:
  ea:	10 e0       	ldi	r17, 0x00	; 0
  ec:	a6 e7       	ldi	r26, 0x76	; 118
  ee:	b0 e0       	ldi	r27, 0x00	; 0
  f0:	01 c0       	rjmp	.+2      	; 0xf4 <.do_clear_bss_start>

000000f2 <.do_clear_bss_loop>:
  f2:	1d 92       	st	X+, r1

000000f4 <.do_clear_bss_start>:
  f4:	a8 3d       	cpi	r26, 0xD8	; 216
  f6:	b1 07       	cpc	r27, r17
  f8:	e1 f7       	brne	.-8      	; 0xf2 <.do_clear_bss_loop>
  fa:	59 d2       	rcall	.+1202   	; 0x5ae <main>
  fc:	ba c6       	rjmp	.+3444   	; 0xe72 <_exit>

000000fe <__bad_interrupt>:
  fe:	80 cf       	rjmp	.-256    	; 0x0 <__vectors>

00000100 <init_twi>:
#include "TWI.h"

void init_twi()
{
	return;
}
 100:	08 95       	ret

00000102 <init_usart>:
////////////////////////////////////////////////////////////////////////
void init_usart()
{
	// set the baud-rate according to table 60 in datasheet
	// 12 = 76.8k @ 16.000 MHz
	UBRRH = 0;
 102:	10 bc       	out	0x20, r1	; 32
	UBRRL = 51;
 104:	83 e3       	ldi	r24, 0x33	; 51
 106:	89 b9       	out	0x09, r24	; 9

	// enable receiver/transmitter - interrupt driven
	UCSRB = (1<<RXCIE)|(1<<TXCIE)|(1<<RXEN)|(1<<TXEN);
 108:	88 ed       	ldi	r24, 0xD8	; 216
 10a:	8a b9       	out	0x0a, r24	; 10
	// frame format: 8N1
	UCSRC = (1<<URSEL)|(3<<UCSZ0);
 10c:	86 e8       	ldi	r24, 0x86	; 134
 10e:	80 bd       	out	0x20, r24	; 32
}
 110:	08 95       	ret

00000112 <usart_putbyte>:
// parameters: byte to send over USART
// return: nothing
////////////////////////////////////////////////////////////////////////
void usart_putbyte(uint8_t c)
{
	usart_tx.buf[usart_tx.writeto] =c;
 112:	90 91 87 00 	lds	r25, 0x0087
 116:	e6 e7       	ldi	r30, 0x76	; 118
 118:	f0 e0       	ldi	r31, 0x00	; 0
 11a:	e9 0f       	add	r30, r25
 11c:	f1 1d       	adc	r31, r1
 11e:	80 83       	st	Z, r24
	usart_tx.writeto++;
 120:	80 91 87 00 	lds	r24, 0x0087
 124:	8f 5f       	subi	r24, 0xFF	; 255
 126:	80 93 87 00 	sts	0x0087, r24
	usart_tx.writeto &= USART_TX_MAX;
 12a:	80 91 87 00 	lds	r24, 0x0087
 12e:	8f 70       	andi	r24, 0x0F	; 15
 130:	80 93 87 00 	sts	0x0087, r24

	usart_tx.avail++;
 134:	80 91 88 00 	lds	r24, 0x0088
 138:	8f 5f       	subi	r24, 0xFF	; 255
 13a:	80 93 88 00 	sts	0x0088, r24
}
 13e:	08 95       	ret

00000140 <usart_avail>:

uint8_t usart_avail()
{
	return usart_rx.avail;
 140:	80 91 ab 00 	lds	r24, 0x00AB
}
 144:	08 95       	ret

00000146 <usart_getbyte>:
// parameters: nothing
// return: received byte
////////////////////////////////////////////////////////////////////////
uint8_t usart_getbyte(void)
{
	if (usart_rx.avail ==0)
 146:	80 91 ab 00 	lds	r24, 0x00AB
 14a:	88 23       	and	r24, r24
 14c:	e1 f0       	breq	.+56     	; 0x186 <usart_getbyte+0x40>
		return 0;

	uint8_t c = usart_rx.buf[usart_rx.readfrom];
 14e:	e0 91 a9 00 	lds	r30, 0x00A9
 152:	f0 e0       	ldi	r31, 0x00	; 0
 154:	e7 57       	subi	r30, 0x77	; 119
 156:	ff 4f       	sbci	r31, 0xFF	; 255
 158:	e0 81       	ld	r30, Z
	usart_rx.readfrom++;
 15a:	80 91 a9 00 	lds	r24, 0x00A9
 15e:	8f 5f       	subi	r24, 0xFF	; 255
 160:	80 93 a9 00 	sts	0x00A9, r24
	usart_rx.readfrom &= USART_RX_MAX;
 164:	80 91 a9 00 	lds	r24, 0x00A9
 168:	8f 71       	andi	r24, 0x1F	; 31
 16a:	80 93 a9 00 	sts	0x00A9, r24
	
	usart_rx.avail--;
 16e:	80 91 ab 00 	lds	r24, 0x00AB
 172:	81 50       	subi	r24, 0x01	; 1
 174:	80 93 ab 00 	sts	0x00AB, r24

	// set DTR LOW, to signal PC that sending data is allowed
	// MAX232 inverts the signal
	if (usart_rx.avail < USART_RX_MAX)
 178:	80 91 ab 00 	lds	r24, 0x00AB
 17c:	8f 31       	cpi	r24, 0x1F	; 31
 17e:	08 f4       	brcc	.+2      	; 0x182 <usart_getbyte+0x3c>
		PORTD &= ~_BV(CTS);
 180:	94 98       	cbi	0x12, 4	; 18

	return c;
}
 182:	8e 2f       	mov	r24, r30
 184:	08 95       	ret
// parameters: nothing
// return: received byte
////////////////////////////////////////////////////////////////////////
uint8_t usart_getbyte(void)
{
	if (usart_rx.avail ==0)
 186:	e0 e0       	ldi	r30, 0x00	; 0
	// MAX232 inverts the signal
	if (usart_rx.avail < USART_RX_MAX)
		PORTD &= ~_BV(CTS);

	return c;
}
 188:	8e 2f       	mov	r24, r30
 18a:	08 95       	ret

0000018c <__vector_11>:


//////////////////////////// ISRs /////////////////////////////////////
///////////////////////////////////////////////////////////////////////
ISR(USART_RXC_vect)
{
 18c:	1f 92       	push	r1
 18e:	0f 92       	push	r0
 190:	0f b6       	in	r0, 0x3f	; 63
 192:	0f 92       	push	r0
 194:	11 24       	eor	r1, r1
 196:	8f 93       	push	r24
 198:	ef 93       	push	r30
 19a:	ff 93       	push	r31
	uint8_t c =UDR;
 19c:	8c b1       	in	r24, 0x0c	; 12

	usart_rx.buf[usart_rx.writeto] =c;
 19e:	e0 91 aa 00 	lds	r30, 0x00AA
 1a2:	f0 e0       	ldi	r31, 0x00	; 0
 1a4:	e7 57       	subi	r30, 0x77	; 119
 1a6:	ff 4f       	sbci	r31, 0xFF	; 255
 1a8:	80 83       	st	Z, r24
	usart_rx.writeto++;
 1aa:	80 91 aa 00 	lds	r24, 0x00AA
 1ae:	8f 5f       	subi	r24, 0xFF	; 255
 1b0:	80 93 aa 00 	sts	0x00AA, r24
	usart_rx.writeto &= USART_RX_MAX;
 1b4:	80 91 aa 00 	lds	r24, 0x00AA
 1b8:	8f 71       	andi	r24, 0x1F	; 31
 1ba:	80 93 aa 00 	sts	0x00AA, r24
	usart_rx.avail++;
 1be:	80 91 ab 00 	lds	r24, 0x00AB
 1c2:	8f 5f       	subi	r24, 0xFF	; 255
 1c4:	80 93 ab 00 	sts	0x00AB, r24
	// if RX buf is full -> usart_rx.avail ==USART_RX_MAX
	// drive CTS line HIGH to signal send hold to PC
	// PC MUST check CTS line EVERY time prior to sending
	// data to uC
	// MAX232 inverts the signal
	if (usart_rx.avail ==USART_RX_MAX)
 1c8:	80 91 ab 00 	lds	r24, 0x00AB
 1cc:	8f 31       	cpi	r24, 0x1F	; 31
 1ce:	09 f4       	brne	.+2      	; 0x1d2 <__vector_11+0x46>
		PORTD |= _BV(CTS);
 1d0:	94 9a       	sbi	0x12, 4	; 18
}
 1d2:	ff 91       	pop	r31
 1d4:	ef 91       	pop	r30
 1d6:	8f 91       	pop	r24
 1d8:	0f 90       	pop	r0
 1da:	0f be       	out	0x3f, r0	; 63
 1dc:	0f 90       	pop	r0
 1de:	1f 90       	pop	r1
 1e0:	18 95       	reti

000001e2 <__vector_13>:

ISR(USART_TXC_vect)
{
 1e2:	1f 92       	push	r1
 1e4:	0f 92       	push	r0
 1e6:	0f b6       	in	r0, 0x3f	; 63
 1e8:	0f 92       	push	r0
 1ea:	11 24       	eor	r1, r1
}
 1ec:	0f 90       	pop	r0
 1ee:	0f be       	out	0x3f, r0	; 63
 1f0:	0f 90       	pop	r0
 1f2:	1f 90       	pop	r1
 1f4:	18 95       	reti

000001f6 <__vector_12>:

ISR(USART_UDRE_vect)
{
 1f6:	1f 92       	push	r1
 1f8:	0f 92       	push	r0
 1fa:	0f b6       	in	r0, 0x3f	; 63
 1fc:	0f 92       	push	r0
 1fe:	11 24       	eor	r1, r1
 200:	8f 93       	push	r24
 202:	ef 93       	push	r30
 204:	ff 93       	push	r31
	if (usart_tx.avail ==0)
 206:	80 91 88 00 	lds	r24, 0x0088
 20a:	88 23       	and	r24, r24
 20c:	f1 f0       	breq	.+60     	; 0x24a <__vector_12+0x54>
		UCSRA |= (1<<UDRE);
	}
	else
	{
		// get byte from TX-buffer and send it down the line
		UDR =usart_tx.buf[usart_tx.readfrom];
 20e:	e0 91 86 00 	lds	r30, 0x0086
 212:	f0 e0       	ldi	r31, 0x00	; 0
 214:	ea 58       	subi	r30, 0x8A	; 138
 216:	ff 4f       	sbci	r31, 0xFF	; 255
 218:	80 81       	ld	r24, Z
 21a:	8c b9       	out	0x0c, r24	; 12
		usart_tx.readfrom++;
 21c:	80 91 86 00 	lds	r24, 0x0086
 220:	8f 5f       	subi	r24, 0xFF	; 255
 222:	80 93 86 00 	sts	0x0086, r24
		usart_tx.readfrom &= USART_TX_MAX;
 226:	80 91 86 00 	lds	r24, 0x0086
 22a:	8f 70       	andi	r24, 0x0F	; 15
 22c:	80 93 86 00 	sts	0x0086, r24
		usart_tx.avail--;
 230:	80 91 88 00 	lds	r24, 0x0088
 234:	81 50       	subi	r24, 0x01	; 1
 236:	80 93 88 00 	sts	0x0088, r24
	}	
}
 23a:	ff 91       	pop	r31
 23c:	ef 91       	pop	r30
 23e:	8f 91       	pop	r24
 240:	0f 90       	pop	r0
 242:	0f be       	out	0x3f, r0	; 63
 244:	0f 90       	pop	r0
 246:	1f 90       	pop	r1
 248:	18 95       	reti
ISR(USART_UDRE_vect)
{
	if (usart_tx.avail ==0)
	{
		// no more bytes in TX-buffer, so disable UDRE interrupt
		UCSRB &= ~(1<<UDRIE);
 24a:	55 98       	cbi	0x0a, 5	; 10
		// clear UDRE flag, to stop further interrupts
		UCSRA |= (1<<UDRE);
 24c:	5d 9a       	sbi	0x0b, 5	; 11
		UDR =usart_tx.buf[usart_tx.readfrom];
		usart_tx.readfrom++;
		usart_tx.readfrom &= USART_TX_MAX;
		usart_tx.avail--;
	}	
}
 24e:	ff 91       	pop	r31
 250:	ef 91       	pop	r30
 252:	8f 91       	pop	r24
 254:	0f 90       	pop	r0
 256:	0f be       	out	0x3f, r0	; 63
 258:	0f 90       	pop	r0
 25a:	1f 90       	pop	r1
 25c:	18 95       	reti

0000025e <usart_send>:
	return usart_rx.avail;
}


void usart_send(uint8_t *buf, uint8_t len)
{
 25e:	dc 01       	movw	r26, r24
	do {
		
		usart_putbyte(*buf++);
 260:	8d 91       	ld	r24, X+
// parameters: byte to send over USART
// return: nothing
////////////////////////////////////////////////////////////////////////
void usart_putbyte(uint8_t c)
{
	usart_tx.buf[usart_tx.writeto] =c;
 262:	e0 91 87 00 	lds	r30, 0x0087
 266:	f0 e0       	ldi	r31, 0x00	; 0
 268:	ea 58       	subi	r30, 0x8A	; 138
 26a:	ff 4f       	sbci	r31, 0xFF	; 255
 26c:	80 83       	st	Z, r24
	usart_tx.writeto++;
 26e:	80 91 87 00 	lds	r24, 0x0087
 272:	8f 5f       	subi	r24, 0xFF	; 255
 274:	80 93 87 00 	sts	0x0087, r24
	usart_tx.writeto &= USART_TX_MAX;
 278:	80 91 87 00 	lds	r24, 0x0087
 27c:	8f 70       	andi	r24, 0x0F	; 15
 27e:	80 93 87 00 	sts	0x0087, r24

	usart_tx.avail++;
 282:	80 91 88 00 	lds	r24, 0x0088
 286:	8f 5f       	subi	r24, 0xFF	; 255
 288:	80 93 88 00 	sts	0x0088, r24
void usart_send(uint8_t *buf, uint8_t len)
{
	do {
		
		usart_putbyte(*buf++);
		len--;
 28c:	61 50       	subi	r22, 0x01	; 1
	} while(len);
 28e:	41 f7       	brne	.-48     	; 0x260 <usart_send+0x2>

	// enable UDRE interrupt
	UCSRB |=(1<<UDRIE);
 290:	55 9a       	sbi	0x0a, 5	; 10
}
 292:	08 95       	ret

00000294 <__vector_3>:

void read_encoders();

////////////////////// Timer2 compare interrupt ////////////////////////
ISR(TIMER2_COMP_vect)
{
 294:	1f 92       	push	r1
 296:	0f 92       	push	r0
 298:	0f b6       	in	r0, 0x3f	; 63
 29a:	0f 92       	push	r0
 29c:	11 24       	eor	r1, r1
 29e:	8f 93       	push	r24
	bt_poll_cnt++;
 2a0:	80 91 d6 00 	lds	r24, 0x00D6
 2a4:	8f 5f       	subi	r24, 0xFF	; 255
 2a6:	80 93 d6 00 	sts	0x00D6, r24
	//read_encoders(); // read encoders every 1ms
	gFlags |= ROTENC_POLL;
 2aa:	80 91 d5 00 	lds	r24, 0x00D5
 2ae:	82 60       	ori	r24, 0x02	; 2
 2b0:	80 93 d5 00 	sts	0x00D5, r24

	if (bt_poll_cnt == BUTTON_POLLING_INTERVAL)
 2b4:	80 91 d6 00 	lds	r24, 0x00D6
 2b8:	84 30       	cpi	r24, 0x04	; 4
 2ba:	39 f4       	brne	.+14     	; 0x2ca <__vector_3+0x36>
	{
		bt_poll_cnt =0;
 2bc:	10 92 d6 00 	sts	0x00D6, r1
		gFlags |=BUTTON_POLL;
 2c0:	80 91 d5 00 	lds	r24, 0x00D5
 2c4:	81 60       	ori	r24, 0x01	; 1
 2c6:	80 93 d5 00 	sts	0x00D5, r24
			limiter_flags |=PITLIMITER_TOGGLE;
		}
	}
#endif /* _WITH_DASHBOARD */

}
 2ca:	8f 91       	pop	r24
 2cc:	0f 90       	pop	r0
 2ce:	0f be       	out	0x3f, r0	; 63
 2d0:	0f 90       	pop	r0
 2d2:	1f 90       	pop	r1
 2d4:	18 95       	reti

000002d6 <__vector_8>:

ISR(TIMER1_OVF_vect)
{
 2d6:	1f 92       	push	r1
 2d8:	0f 92       	push	r0
 2da:	0f b6       	in	r0, 0x3f	; 63
 2dc:	0f 92       	push	r0
 2de:	11 24       	eor	r1, r1
 2e0:	8f 93       	push	r24
 2e2:	9f 93       	push	r25
	// update pwm_dc
	//OCR1A =(pwm_dc/100.0)*0xFF;
	OCR1A = pwm_dc;
 2e4:	80 91 d2 00 	lds	r24, 0x00D2
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	9b bd       	out	0x2b, r25	; 43
 2ec:	8a bd       	out	0x2a, r24	; 42
}
 2ee:	9f 91       	pop	r25
 2f0:	8f 91       	pop	r24
 2f2:	0f 90       	pop	r0
 2f4:	0f be       	out	0x3f, r0	; 63
 2f6:	0f 90       	pop	r0
 2f8:	1f 90       	pop	r1
 2fa:	18 95       	reti

000002fc <read_encoders>:
{
	// clear old encoder values
	//buttons[RE_BB_12] =0;

	/*** BRAKE BIAS encoder ***/
	if (!RENC_BB_PINA)
 2fc:	b2 99       	sbic	0x16, 2	; 22
 2fe:	05 c0       	rjmp	.+10     	; 0x30a <read_encoders+0xe>
		renc_bb_status |=2;
 300:	80 91 c3 00 	lds	r24, 0x00C3
 304:	82 60       	ori	r24, 0x02	; 2
 306:	80 93 c3 00 	sts	0x00C3, r24
	if (!RENC_BB_PINB)
 30a:	87 99       	sbic	0x10, 7	; 16
 30c:	05 c0       	rjmp	.+10     	; 0x318 <read_encoders+0x1c>
		renc_bb_status |=1;
 30e:	80 91 c3 00 	lds	r24, 0x00C3
 312:	81 60       	ori	r24, 0x01	; 1
 314:	80 93 c3 00 	sts	0x00C3, r24

	if ((renc_bb_status & 0xC) ==0xC) {
 318:	80 91 c3 00 	lds	r24, 0x00C3
 31c:	8c 70       	andi	r24, 0x0C	; 12
 31e:	8c 30       	cpi	r24, 0x0C	; 12
 320:	09 f4       	brne	.+2      	; 0x324 <read_encoders+0x28>
 322:	63 c0       	rjmp	.+198    	; 0x3ea <read_encoders+0xee>
		else if (renc_bb_status ==2) {
			buttons[RE_BB_12] =0x80;
			//			gFlags |= BUTTON_UPDATE;
		}
	}
	renc_bb_status =(renc_bb_status << 2) & 0xF;
 324:	80 91 c3 00 	lds	r24, 0x00C3
 328:	88 0f       	add	r24, r24
 32a:	88 0f       	add	r24, r24
 32c:	8c 70       	andi	r24, 0x0C	; 12
 32e:	80 93 c3 00 	sts	0x00C3, r24
	/***	***/

	/*** selection encoder 1 ***/
	if (!RENC_SEL1_PINA)
 332:	86 99       	sbic	0x10, 6	; 16
 334:	05 c0       	rjmp	.+10     	; 0x340 <read_encoders+0x44>
		renc_sel1_status |=2;
 336:	80 91 cc 00 	lds	r24, 0x00CC
 33a:	82 60       	ori	r24, 0x02	; 2
 33c:	80 93 cc 00 	sts	0x00CC, r24
	if (!RENC_SEL1_PINB)
 340:	85 99       	sbic	0x10, 5	; 16
 342:	05 c0       	rjmp	.+10     	; 0x34e <read_encoders+0x52>
		renc_sel1_status |=1;
 344:	80 91 cc 00 	lds	r24, 0x00CC
 348:	81 60       	ori	r24, 0x01	; 1
 34a:	80 93 cc 00 	sts	0x00CC, r24

	if ((renc_sel1_status & 0xC) ==0xC) {
 34e:	80 91 cc 00 	lds	r24, 0x00CC
 352:	8c 70       	andi	r24, 0x0C	; 12
 354:	8c 30       	cpi	r24, 0x0C	; 12
 356:	99 f1       	breq	.+102    	; 0x3be <read_encoders+0xc2>
				buttons[RE_BB_12] =0x2;
				//				gFlags |= BUTTON_UPDATE;
			}
		}
	}
	renc_sel1_status = (renc_sel1_status << 2) & 0xF;
 358:	80 91 cc 00 	lds	r24, 0x00CC
 35c:	88 0f       	add	r24, r24
 35e:	88 0f       	add	r24, r24
 360:	8c 70       	andi	r24, 0x0C	; 12
 362:	80 93 cc 00 	sts	0x00CC, r24
	/***	***/

	/*** selection encoder 2 ***/
	if (!RENC_SEL2_PINA)
 366:	9a 99       	sbic	0x13, 2	; 19
 368:	05 c0       	rjmp	.+10     	; 0x374 <read_encoders+0x78>
		renc_sel2_status |=2;
 36a:	80 91 c6 00 	lds	r24, 0x00C6
 36e:	82 60       	ori	r24, 0x02	; 2
 370:	80 93 c6 00 	sts	0x00C6, r24
	if (!RENC_SEL2_PINB)
 374:	9b 99       	sbic	0x13, 3	; 19
 376:	05 c0       	rjmp	.+10     	; 0x382 <read_encoders+0x86>
		renc_sel2_status |=1;
 378:	80 91 c6 00 	lds	r24, 0x00C6
 37c:	81 60       	ori	r24, 0x01	; 1
 37e:	80 93 c6 00 	sts	0x00C6, r24

	if ((renc_sel2_status & 0xC) ==0xC) {
 382:	80 91 c6 00 	lds	r24, 0x00C6
 386:	8c 70       	andi	r24, 0x0C	; 12
 388:	8c 30       	cpi	r24, 0x0C	; 12
 38a:	41 f0       	breq	.+16     	; 0x39c <read_encoders+0xa0>
		else if (renc_sel2_status ==2) {
			buttons[RE_BB_12] =0x8;
			//			gFlags |= BUTTON_UPDATE;
		}
	}
	renc_sel2_status = (renc_sel2_status << 2) & 0xF;
 38c:	80 91 c6 00 	lds	r24, 0x00C6
 390:	88 0f       	add	r24, r24
 392:	88 0f       	add	r24, r24
 394:	8c 70       	andi	r24, 0x0C	; 12
 396:	80 93 c6 00 	sts	0x00C6, r24
	/***	***/
}
 39a:	08 95       	ret
		renc_sel2_status |=2;
	if (!RENC_SEL2_PINB)
		renc_sel2_status |=1;

	if ((renc_sel2_status & 0xC) ==0xC) {
		renc_sel2_status &= 3;
 39c:	80 91 c6 00 	lds	r24, 0x00C6
 3a0:	83 70       	andi	r24, 0x03	; 3
 3a2:	80 93 c6 00 	sts	0x00C6, r24

		if (renc_sel2_status ==1) {
 3a6:	80 91 c6 00 	lds	r24, 0x00C6
 3aa:	81 30       	cpi	r24, 0x01	; 1
 3ac:	d9 f1       	breq	.+118    	; 0x424 <read_encoders+0x128>
			buttons[RE_BB_12] =0x4;
			//			gFlags |= BUTTON_UPDATE;
		}
		else if (renc_sel2_status ==2) {
 3ae:	80 91 c6 00 	lds	r24, 0x00C6
 3b2:	82 30       	cpi	r24, 0x02	; 2
 3b4:	59 f7       	brne	.-42     	; 0x38c <read_encoders+0x90>
			buttons[RE_BB_12] =0x8;
 3b6:	88 e0       	ldi	r24, 0x08	; 8
 3b8:	80 93 b1 00 	sts	0x00B1, r24
 3bc:	e7 cf       	rjmp	.-50     	; 0x38c <read_encoders+0x90>
		renc_sel1_status |=2;
	if (!RENC_SEL1_PINB)
		renc_sel1_status |=1;

	if ((renc_sel1_status & 0xC) ==0xC) {
		renc_sel1_status &= 3;
 3be:	80 91 cc 00 	lds	r24, 0x00CC
 3c2:	83 70       	andi	r24, 0x03	; 3
 3c4:	80 93 cc 00 	sts	0x00CC, r24

		if (renc_sel1_status ==1) {
 3c8:	90 91 cc 00 	lds	r25, 0x00CC
 3cc:	91 30       	cpi	r25, 0x01	; 1
 3ce:	f9 f0       	breq	.+62     	; 0x40e <read_encoders+0x112>
			else {
				buttons[RE_BB_12] =0x1;
				//				gFlags |= BUTTON_UPDATE;
			}
		}
		else if (renc_sel1_status ==2) {
 3d0:	90 91 cc 00 	lds	r25, 0x00CC
 3d4:	92 30       	cpi	r25, 0x02	; 2
 3d6:	09 f0       	breq	.+2      	; 0x3da <read_encoders+0xde>
 3d8:	bf cf       	rjmp	.-130    	; 0x358 <read_encoders+0x5c>
			if (lastRotSw_2 & SEL_LED_ON) {
 3da:	80 91 cd 00 	lds	r24, 0x00CD
 3de:	86 ff       	sbrs	r24, 6
 3e0:	1a c0       	rjmp	.+52     	; 0x416 <read_encoders+0x11a>
				buttons[RE_BB_12] =0x20;
 3e2:	80 e2       	ldi	r24, 0x20	; 32
 3e4:	80 93 b1 00 	sts	0x00B1, r24
 3e8:	b7 cf       	rjmp	.-146    	; 0x358 <read_encoders+0x5c>
		renc_bb_status |=2;
	if (!RENC_BB_PINB)
		renc_bb_status |=1;

	if ((renc_bb_status & 0xC) ==0xC) {
		renc_bb_status &= 3;
 3ea:	80 91 c3 00 	lds	r24, 0x00C3
 3ee:	83 70       	andi	r24, 0x03	; 3
 3f0:	80 93 c3 00 	sts	0x00C3, r24

		if (renc_bb_status == 1) {
 3f4:	80 91 c3 00 	lds	r24, 0x00C3
 3f8:	81 30       	cpi	r24, 0x01	; 1
 3fa:	81 f0       	breq	.+32     	; 0x41c <read_encoders+0x120>
			buttons[RE_BB_12] =0x40;
			//			gFlags |= BUTTON_UPDATE;
		}
		else if (renc_bb_status ==2) {
 3fc:	80 91 c3 00 	lds	r24, 0x00C3
 400:	82 30       	cpi	r24, 0x02	; 2
 402:	09 f0       	breq	.+2      	; 0x406 <read_encoders+0x10a>
 404:	8f cf       	rjmp	.-226    	; 0x324 <read_encoders+0x28>
			buttons[RE_BB_12] =0x80;
 406:	80 e8       	ldi	r24, 0x80	; 128
 408:	80 93 b1 00 	sts	0x00B1, r24
 40c:	8b cf       	rjmp	.-234    	; 0x324 <read_encoders+0x28>

	if ((renc_sel1_status & 0xC) ==0xC) {
		renc_sel1_status &= 3;

		if (renc_sel1_status ==1) {
			if (lastRotSw_2 & SEL_LED_ON) {
 40e:	80 91 cd 00 	lds	r24, 0x00CD
 412:	86 fd       	sbrc	r24, 6
 414:	0b c0       	rjmp	.+22     	; 0x42c <read_encoders+0x130>
			if (lastRotSw_2 & SEL_LED_ON) {
				buttons[RE_BB_12] =0x20;
				//				gFlags |= BUTTON_UPDATE;
			}
			else {
				buttons[RE_BB_12] =0x2;
 416:	90 93 b1 00 	sts	0x00B1, r25
 41a:	9e cf       	rjmp	.-196    	; 0x358 <read_encoders+0x5c>

	if ((renc_bb_status & 0xC) ==0xC) {
		renc_bb_status &= 3;

		if (renc_bb_status == 1) {
			buttons[RE_BB_12] =0x40;
 41c:	80 e4       	ldi	r24, 0x40	; 64
 41e:	80 93 b1 00 	sts	0x00B1, r24
 422:	80 cf       	rjmp	.-256    	; 0x324 <read_encoders+0x28>

	if ((renc_sel2_status & 0xC) ==0xC) {
		renc_sel2_status &= 3;

		if (renc_sel2_status ==1) {
			buttons[RE_BB_12] =0x4;
 424:	84 e0       	ldi	r24, 0x04	; 4
 426:	80 93 b1 00 	sts	0x00B1, r24
 42a:	b0 cf       	rjmp	.-160    	; 0x38c <read_encoders+0x90>
	if ((renc_sel1_status & 0xC) ==0xC) {
		renc_sel1_status &= 3;

		if (renc_sel1_status ==1) {
			if (lastRotSw_2 & SEL_LED_ON) {
				buttons[RE_BB_12] =0x10;
 42c:	80 e1       	ldi	r24, 0x10	; 16
 42e:	80 93 b1 00 	sts	0x00B1, r24
 432:	92 cf       	rjmp	.-220    	; 0x358 <read_encoders+0x5c>

00000434 <update_config>:
	/***	***/
}

// update_config();
void update_config(uint8_t cc, uint8_t* buf, uint8_t len)
{
 434:	fb 01       	movw	r30, r22
	if (buf !=NULL) {
 436:	61 15       	cp	r22, r1
 438:	71 05       	cpc	r23, r1
 43a:	19 f0       	breq	.+6      	; 0x442 <update_config+0xe>

		if (buf[0] =='L') { // update LED brightness sub-command
 43c:	80 81       	ld	r24, Z
 43e:	8c 34       	cpi	r24, 0x4C	; 76
 440:	09 f0       	breq	.+2      	; 0x444 <update_config+0x10>
 442:	08 95       	ret

			// set PWM duty cycle here to dim blue LEDs
			pwm_dc =buf[1];
 444:	81 81       	ldd	r24, Z+1	; 0x01
 446:	80 93 d2 00 	sts	0x00D2, r24
 44a:	08 95       	ret

0000044c <__vector_1>:
	//OCR1A =(pwm_dc/100.0)*0xFF;
	OCR1A = pwm_dc;
}

ISR(INT0_vect)
{
 44c:	1f 92       	push	r1
 44e:	0f 92       	push	r0
 450:	0f b6       	in	r0, 0x3f	; 63
 452:	0f 92       	push	r0
 454:	11 24       	eor	r1, r1
 456:	2f 93       	push	r18
 458:	3f 93       	push	r19
 45a:	4f 93       	push	r20
 45c:	5f 93       	push	r21
 45e:	6f 93       	push	r22
 460:	7f 93       	push	r23
 462:	8f 93       	push	r24
 464:	9f 93       	push	r25
 466:	af 93       	push	r26
 468:	bf 93       	push	r27
 46a:	ef 93       	push	r30
 46c:	ff 93       	push	r31
 46e:	df 93       	push	r29
 470:	cf 93       	push	r28
 472:	0f 92       	push	r0
 474:	cd b7       	in	r28, 0x3d	; 61
 476:	de b7       	in	r29, 0x3e	; 62
	// ensure that interrupt flag is cleared
	//GIFR = (1<<INTF0);

	uint8_t d ='W';
 478:	87 e5       	ldi	r24, 0x57	; 87
 47a:	89 83       	std	Y+1, r24	; 0x01
	usart_send((uint8_t*)&d, 1);
 47c:	ce 01       	movw	r24, r28
 47e:	01 96       	adiw	r24, 0x01	; 1
 480:	61 e0       	ldi	r22, 0x01	; 1
 482:	ed de       	rcall	.-550    	; 0x25e <usart_send>

}
 484:	0f 90       	pop	r0
 486:	cf 91       	pop	r28
 488:	df 91       	pop	r29
 48a:	ff 91       	pop	r31
 48c:	ef 91       	pop	r30
 48e:	bf 91       	pop	r27
 490:	af 91       	pop	r26
 492:	9f 91       	pop	r25
 494:	8f 91       	pop	r24
 496:	7f 91       	pop	r23
 498:	6f 91       	pop	r22
 49a:	5f 91       	pop	r21
 49c:	4f 91       	pop	r20
 49e:	3f 91       	pop	r19
 4a0:	2f 91       	pop	r18
 4a2:	0f 90       	pop	r0
 4a4:	0f be       	out	0x3f, r0	; 63
 4a6:	0f 90       	pop	r0
 4a8:	1f 90       	pop	r1
 4aa:	18 95       	reti

000004ac <init>:

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

void init()
{
 4ac:	ff 92       	push	r15
 4ae:	0f 93       	push	r16
 4b0:	1f 93       	push	r17
 4b2:	df 93       	push	r29
 4b4:	cf 93       	push	r28
 4b6:	00 d0       	rcall	.+0      	; 0x4b8 <init+0xc>
 4b8:	cd b7       	in	r28, 0x3d	; 61
 4ba:	de b7       	in	r29, 0x3e	; 62
	gFlags =0;
 4bc:	10 92 d5 00 	sts	0x00D5, r1
	bt_poll_cnt =0;
 4c0:	10 92 d6 00 	sts	0x00D6, r1
	renc_bb_status =0;
 4c4:	10 92 c3 00 	sts	0x00C3, r1
	renc_sel1_status =0;
 4c8:	10 92 cc 00 	sts	0x00CC, r1
	renc_sel2_status =0;
 4cc:	10 92 c6 00 	sts	0x00C6, r1

	pwm_dc =128;
 4d0:	10 e8       	ldi	r17, 0x80	; 128
 4d2:	10 93 d2 00 	sts	0x00D2, r17

	lastRotSw_1 =0;
 4d6:	10 92 cf 00 	sts	0x00CF, r1
 4da:	10 92 ce 00 	sts	0x00CE, r1
	lastRotSw_2 =0;
 4de:	10 92 cd 00 	sts	0x00CD, r1
	RotSw_1 =0;
 4e2:	10 92 d4 00 	sts	0x00D4, r1
 4e6:	10 92 d3 00 	sts	0x00D3, r1
	RotSw_2 =0;
 4ea:	10 92 c8 00 	sts	0x00C8, r1

	// set in/outputs of uC
	// set all ports as output
	DDRC =0xFF;
 4ee:	8f ef       	ldi	r24, 0xFF	; 255
 4f0:	84 bb       	out	0x14, r24	; 20
	DDRB =0xFF;
 4f2:	87 bb       	out	0x17, r24	; 23
	DDRD =0xFF;
 4f4:	81 bb       	out	0x11, r24	; 17

	// all ports low
	PORTC =0;
 4f6:	15 ba       	out	0x15, r1	; 21
	PORTB =0;
 4f8:	18 ba       	out	0x18, r1	; 24
	PORTD =0;
 4fa:	12 ba       	out	0x12, r1	; 18

	// set CTS line HIGH during initialization
	// (! the MAX232 inverts! the signal !)
	PORTD |=_BV(CTS);
 4fc:	94 9a       	sbi	0x12, 4	; 18

	DDRC &= ~((1<<PC2)|(1<<PC3)|(1<<PC0));
 4fe:	84 b3       	in	r24, 0x14	; 20
 500:	82 7f       	andi	r24, 0xF2	; 242
 502:	84 bb       	out	0x14, r24	; 20
	DDRD &= ~((1<<PD2)|(1<<PD5)|(1<<PD6)|(1<<PD7));
 504:	81 b3       	in	r24, 0x11	; 17
 506:	8b 71       	andi	r24, 0x1B	; 27
 508:	81 bb       	out	0x11, r24	; 17
	DDRB &= ~((1<<PB2));
 50a:	ba 98       	cbi	0x17, 2	; 23

	// enable pull-ups for rotary encoder inputs
	PORTC |= (1<<PC2)|(1<<PC3);
 50c:	85 b3       	in	r24, 0x15	; 21
 50e:	8c 60       	ori	r24, 0x0C	; 12
 510:	85 bb       	out	0x15, r24	; 21
	PORTD |= (1<<PD5)|(1<<PD6)|(1<<PD7);
 512:	82 b3       	in	r24, 0x12	; 18
 514:	80 6e       	ori	r24, 0xE0	; 224
 516:	82 bb       	out	0x12, r24	; 18
	PORTB |= (1<<PB2);
 518:	c2 9a       	sbi	0x18, 2	; 24

	// disable blue LEDs
	// ( needed because of PNP transistor -> active LOW)
	PORTB |= _BV(PB1);
 51a:	c1 9a       	sbi	0x18, 1	; 24

	// enable ADC0 for temp sensor
	// ...

	init_usart();
 51c:	f2 dd       	rcall	.-1052   	; 0x102 <init_usart>
	TWI_Master_Initialise();
 51e:	e3 d3       	rcall	.+1990   	; 0xce6 <TWI_Master_Initialise>

	// init Timer2 (8-bit)
	TCCR2 =(1<<WGM21);	// (CTC-mode)/)
 520:	98 e0       	ldi	r25, 0x08	; 8
 522:	95 bd       	out	0x25, r25	; 37
	OCR2 =250;	//interrupt fires every 1ms
 524:	8a ef       	ldi	r24, 0xFA	; 250
 526:	83 bd       	out	0x23, r24	; 35
	TIMSK =(1<<OCIE2);	// compare interrupt
 528:	19 bf       	out	0x39, r17	; 57

	// configure PB1 (OC1A) for PWM (-> LEDs)
	// init TIMER1 for 8-bit Fast-PWM
	TCCR1A = (1<<COM1A0) | (1<<COM1A1) | (1<<WGM10);
 52a:	81 ec       	ldi	r24, 0xC1	; 193
 52c:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = (1<<WGM12);
 52e:	9e bd       	out	0x2e, r25	; 46
	TIMSK |= (1<<TOIE1);
 530:	89 b7       	in	r24, 0x39	; 57
 532:	84 60       	ori	r24, 0x04	; 4
 534:	89 bf       	out	0x39, r24	; 57
	OCR1A =pwm_dc;
 536:	80 91 d2 00 	lds	r24, 0x00D2
 53a:	90 e0       	ldi	r25, 0x00	; 0
 53c:	9b bd       	out	0x2b, r25	; 43
 53e:	8a bd       	out	0x2a, r24	; 42

	sei();
 540:	78 94       	sei

	// enable TIMER2 after interrupts are enabled (setting CS22
	// immediately enables the timer!)
	(TCCR2 |= (1<<CS22)); // enable timer with prescaler of 64
 542:	85 b5       	in	r24, 0x25	; 37
 544:	84 60       	ori	r24, 0x04	; 4
 546:	85 bd       	out	0x25, r24	; 37

	// enable PWM
	ENABLE_PWM;
 548:	8e b5       	in	r24, 0x2e	; 46
 54a:	83 60       	ori	r24, 0x03	; 3
 54c:	8e bd       	out	0x2e, r24	; 46
	gFlags |= PWM_LED;
 54e:	80 91 d5 00 	lds	r24, 0x00D5
 552:	80 61       	ori	r24, 0x10	; 16
 554:	80 93 d5 00 	sts	0x00D5, r24
	// now after TWI is initialized and interrupts are enabled,
	// initialize PCF8574 ICs via TWI
	// set all pins of PCF8574 HIGH
	for (uint8_t i =0; i < 5; i++) {
		uint8_t sla =((0x20+i)<<1)|0x0;
		uint8_t buf[2] ={sla,0xFF};
 558:	80 e4       	ldi	r24, 0x40	; 64
 55a:	89 83       	std	Y+1, r24	; 0x01
 55c:	ff 24       	eor	r15, r15
 55e:	fa 94       	dec	r15
 560:	fa 82       	std	Y+2, r15	; 0x02

		TWI_Start_Transceiver_With_Data((unsigned char*)&buf[0], 2);
 562:	8e 01       	movw	r16, r28
 564:	0f 5f       	subi	r16, 0xFF	; 255
 566:	1f 4f       	sbci	r17, 0xFF	; 255
 568:	c8 01       	movw	r24, r16
 56a:	62 e0       	ldi	r22, 0x02	; 2
 56c:	cc d3       	rcall	.+1944   	; 0xd06 <TWI_Start_Transceiver_With_Data>
	// now after TWI is initialized and interrupts are enabled,
	// initialize PCF8574 ICs via TWI
	// set all pins of PCF8574 HIGH
	for (uint8_t i =0; i < 5; i++) {
		uint8_t sla =((0x20+i)<<1)|0x0;
		uint8_t buf[2] ={sla,0xFF};
 56e:	82 e4       	ldi	r24, 0x42	; 66
 570:	89 83       	std	Y+1, r24	; 0x01
 572:	fa 82       	std	Y+2, r15	; 0x02

		TWI_Start_Transceiver_With_Data((unsigned char*)&buf[0], 2);
 574:	c8 01       	movw	r24, r16
 576:	62 e0       	ldi	r22, 0x02	; 2
 578:	c6 d3       	rcall	.+1932   	; 0xd06 <TWI_Start_Transceiver_With_Data>
	// now after TWI is initialized and interrupts are enabled,
	// initialize PCF8574 ICs via TWI
	// set all pins of PCF8574 HIGH
	for (uint8_t i =0; i < 5; i++) {
		uint8_t sla =((0x20+i)<<1)|0x0;
		uint8_t buf[2] ={sla,0xFF};
 57a:	84 e4       	ldi	r24, 0x44	; 68
 57c:	89 83       	std	Y+1, r24	; 0x01
 57e:	fa 82       	std	Y+2, r15	; 0x02

		TWI_Start_Transceiver_With_Data((unsigned char*)&buf[0], 2);
 580:	c8 01       	movw	r24, r16
 582:	62 e0       	ldi	r22, 0x02	; 2
 584:	c0 d3       	rcall	.+1920   	; 0xd06 <TWI_Start_Transceiver_With_Data>
	// now after TWI is initialized and interrupts are enabled,
	// initialize PCF8574 ICs via TWI
	// set all pins of PCF8574 HIGH
	for (uint8_t i =0; i < 5; i++) {
		uint8_t sla =((0x20+i)<<1)|0x0;
		uint8_t buf[2] ={sla,0xFF};
 586:	86 e4       	ldi	r24, 0x46	; 70
 588:	89 83       	std	Y+1, r24	; 0x01
 58a:	fa 82       	std	Y+2, r15	; 0x02

		TWI_Start_Transceiver_With_Data((unsigned char*)&buf[0], 2);
 58c:	c8 01       	movw	r24, r16
 58e:	62 e0       	ldi	r22, 0x02	; 2
 590:	ba d3       	rcall	.+1908   	; 0xd06 <TWI_Start_Transceiver_With_Data>
	// now after TWI is initialized and interrupts are enabled,
	// initialize PCF8574 ICs via TWI
	// set all pins of PCF8574 HIGH
	for (uint8_t i =0; i < 5; i++) {
		uint8_t sla =((0x20+i)<<1)|0x0;
		uint8_t buf[2] ={sla,0xFF};
 592:	88 e4       	ldi	r24, 0x48	; 72
 594:	89 83       	std	Y+1, r24	; 0x01
 596:	fa 82       	std	Y+2, r15	; 0x02

		TWI_Start_Transceiver_With_Data((unsigned char*)&buf[0], 2);
 598:	c8 01       	movw	r24, r16
 59a:	62 e0       	ldi	r22, 0x02	; 2
 59c:	b4 d3       	rcall	.+1896   	; 0xd06 <TWI_Start_Transceiver_With_Data>
	}
}
 59e:	0f 90       	pop	r0
 5a0:	0f 90       	pop	r0
 5a2:	cf 91       	pop	r28
 5a4:	df 91       	pop	r29
 5a6:	1f 91       	pop	r17
 5a8:	0f 91       	pop	r16
 5aa:	ff 90       	pop	r15
 5ac:	08 95       	ret

000005ae <main>:



////////////////////////// MAIN ////////////////////////////
int main(void)
{
 5ae:	2f 92       	push	r2
 5b0:	3f 92       	push	r3
 5b2:	4f 92       	push	r4
 5b4:	5f 92       	push	r5
 5b6:	6f 92       	push	r6
 5b8:	7f 92       	push	r7
 5ba:	8f 92       	push	r8
 5bc:	9f 92       	push	r9
 5be:	af 92       	push	r10
 5c0:	bf 92       	push	r11
 5c2:	cf 92       	push	r12
 5c4:	df 92       	push	r13
 5c6:	ef 92       	push	r14
 5c8:	ff 92       	push	r15
 5ca:	0f 93       	push	r16
 5cc:	1f 93       	push	r17
 5ce:	df 93       	push	r29
 5d0:	cf 93       	push	r28
 5d2:	cd b7       	in	r28, 0x3d	; 61
 5d4:	de b7       	in	r29, 0x3e	; 62
 5d6:	63 97       	sbiw	r28, 0x13	; 19
 5d8:	0f b6       	in	r0, 0x3f	; 63
 5da:	f8 94       	cli
 5dc:	de bf       	out	0x3e, r29	; 62
 5de:	0f be       	out	0x3f, r0	; 63
 5e0:	cd bf       	out	0x3d, r28	; 61
	uint8_t fuel =0;
	uint8_t gear_idx =0; // index into gears array fo 7-seg display
	uint8_t misc_mask =0; // misc bitmask (for indicator lights eg low-fuel)
	 */

	uint8_t proto_buf[MAX_PAYLOAD_LEN] ={0};
 5e2:	b5 e0       	ldi	r27, 0x05	; 5
 5e4:	ab 2e       	mov	r10, r27
 5e6:	b1 2c       	mov	r11, r1
 5e8:	ac 0e       	add	r10, r28
 5ea:	bd 1e       	adc	r11, r29
 5ec:	8f e0       	ldi	r24, 0x0F	; 15
 5ee:	f5 01       	movw	r30, r10
 5f0:	11 92       	st	Z+, r1
 5f2:	8a 95       	dec	r24
 5f4:	e9 f7       	brne	.-6      	; 0x5f0 <main+0x42>
	uint8_t len =0;

	uint8_t update_mask =0;
	uint8_t update =0;

	uint8_t twi_buf[2] ={0};
 5f6:	1a 82       	std	Y+2, r1	; 0x02
 5f8:	19 82       	std	Y+1, r1	; 0x01

	init();
 5fa:	58 df       	rcall	.-336    	; 0x4ac <init>

	// set CTS line LOW to signal PC that uC init completed
	// and uC is ready to receive data
	// MAX232 inverts the signal
	PORTD &= ~_BV(CTS);
 5fc:	94 98       	cbi	0x12, 4	; 18
 5fe:	6e 01       	movw	r12, r28
 600:	08 94       	sec
 602:	c1 1c       	adc	r12, r1
 604:	d1 1c       	adc	r13, r1
 606:	a3 e0       	ldi	r26, 0x03	; 3
 608:	6a 2e       	mov	r6, r26
 60a:	71 2c       	mov	r7, r1
 60c:	6c 0e       	add	r6, r28
 60e:	7d 1e       	adc	r7, r29
		if (renc_sel2_status ==1) {
			buttons[RE_BB_12] =0x4;
			//			gFlags |= BUTTON_UPDATE;
		}
		else if (renc_sel2_status ==2) {
			buttons[RE_BB_12] =0x8;
 610:	f8 e0       	ldi	r31, 0x08	; 8
 612:	8f 2e       	mov	r8, r31

	if ((renc_sel2_status & 0xC) ==0xC) {
		renc_sel2_status &= 3;

		if (renc_sel2_status ==1) {
			buttons[RE_BB_12] =0x4;
 614:	e4 e0       	ldi	r30, 0x04	; 4
 616:	5e 2e       	mov	r5, r30
				//				gFlags |= BUTTON_UPDATE;
			}
		}
		else if (renc_sel1_status ==2) {
			if (lastRotSw_2 & SEL_LED_ON) {
				buttons[RE_BB_12] =0x20;
 618:	70 e2       	ldi	r23, 0x20	; 32
 61a:	47 2e       	mov	r4, r23
	if ((renc_sel1_status & 0xC) ==0xC) {
		renc_sel1_status &= 3;

		if (renc_sel1_status ==1) {
			if (lastRotSw_2 & SEL_LED_ON) {
				buttons[RE_BB_12] =0x10;
 61c:	60 e1       	ldi	r22, 0x10	; 16
 61e:	36 2e       	mov	r3, r22
		if (renc_bb_status == 1) {
			buttons[RE_BB_12] =0x40;
			//			gFlags |= BUTTON_UPDATE;
		}
		else if (renc_bb_status ==2) {
			buttons[RE_BB_12] =0x80;
 620:	50 e8       	ldi	r21, 0x80	; 128
 622:	25 2e       	mov	r2, r21
			for (int i =0; i < 5; i++)
			{
				// read button state byte from I/O expander
				// address byte - Bit7:1 = slave address
				//				  Bit0	 = R/W bit
				twi_buf[0] = ((0x20 + i)<<1)|0x1;
 624:	41 e4       	ldi	r20, 0x41	; 65
 626:	94 2e       	mov	r9, r20
	PORTD &= ~_BV(CTS);

	for(;;)
	{

		if (PIND & _BV(DTR))
 628:	82 9b       	sbis	0x10, 2	; 16
 62a:	34 c0       	rjmp	.+104    	; 0x694 <main+0xe6>
		{
			cli();
 62c:	f8 94       	cli

			// if PC is not available, reset all last button states
			// to send new states when PC re-connects
			lastRotSw_2 &= ~0x3F;
 62e:	80 91 cd 00 	lds	r24, 0x00CD
 632:	80 7c       	andi	r24, 0xC0	; 192
 634:	80 93 cd 00 	sts	0x00CD, r24
			lastRotSw_2 &= ~_BV(BT14);
 638:	80 91 cd 00 	lds	r24, 0x00CD
 63c:	8f 77       	andi	r24, 0x7F	; 127
 63e:	80 93 cd 00 	sts	0x00CD, r24
			lastRotSw_1 =0;
 642:	10 92 cf 00 	sts	0x00CF, r1
 646:	10 92 ce 00 	sts	0x00CE, r1
			for (uint8_t i =0; i < BUTTON_STATE_LEN; i++)
				last_buttons[i] =0;
 64a:	10 92 b2 00 	sts	0x00B2, r1
 64e:	10 92 b3 00 	sts	0x00B3, r1
 652:	10 92 b4 00 	sts	0x00B4, r1
 656:	10 92 b5 00 	sts	0x00B5, r1
 65a:	10 92 b6 00 	sts	0x00B6, r1
 65e:	10 92 b7 00 	sts	0x00B7, r1

#ifdef _ENABLE_SLEEP
			// configure PD2 as external interrupt ( on LOW level )
			// to wake MCU from sleep mode
			MCUCR &= ~((1<<ISC01)|(1<<ISC00));
 662:	85 b7       	in	r24, 0x35	; 53
 664:	8c 7f       	andi	r24, 0xFC	; 252
 666:	85 bf       	out	0x35, r24	; 53
			GICR |= (1<<INT0);
 668:	8b b7       	in	r24, 0x3b	; 59
 66a:	80 64       	ori	r24, 0x40	; 64
 66c:	8b bf       	out	0x3b, r24	; 59

			// switch off blue LEDs
			DISABLE_PWM;
 66e:	8e b5       	in	r24, 0x2e	; 46
 670:	88 7f       	andi	r24, 0xF8	; 248
 672:	8e bd       	out	0x2e, r24	; 46
			PORTB |= _BV(PB1);
 674:	c1 9a       	sbi	0x18, 1	; 24

			// set sleep mode
//			set_sleep_mode(SLEEP_MODE_PWR_DOWN);
			set_sleep_mode(SLEEP_MODE_STANDBY);
 676:	85 b7       	in	r24, 0x35	; 53
 678:	8f 78       	andi	r24, 0x8F	; 143
 67a:	80 66       	ori	r24, 0x60	; 96
 67c:	85 bf       	out	0x35, r24	; 53
			sleep_enable();
 67e:	85 b7       	in	r24, 0x35	; 53
 680:	80 68       	ori	r24, 0x80	; 128
 682:	85 bf       	out	0x35, r24	; 53
			sei();
 684:	78 94       	sei
			sleep_cpu();
 686:	88 95       	sleep

			GICR &= (1<<INT0);
 688:	8b b7       	in	r24, 0x3b	; 59
 68a:	80 74       	andi	r24, 0x40	; 64
 68c:	8b bf       	out	0x3b, r24	; 59
			sleep_disable();
 68e:	85 b7       	in	r24, 0x35	; 53
 690:	8f 77       	andi	r24, 0x7F	; 127
 692:	85 bf       	out	0x35, r24	; 53
		// (signals sync between PC and uC)
		// MAX232 inverts the signal
//		while((PIND & _BV(DTR)));
//		gFlags |= GF_DTR;

		if (proto_cc ==0) {
 694:	80 91 d7 00 	lds	r24, 0x00D7
 698:	88 23       	and	r24, r24
 69a:	09 f4       	brne	.+2      	; 0x69e <main+0xf0>
 69c:	75 c1       	rjmp	.+746    	; 0x988 <main+0x3da>
				limiter_flags &= ~PITLIMITER_TOGGLE;
			}
		}
#endif /* _WITH_DASHBOARD */

		if (gFlags & ROTENC_POLL)
 69e:	80 91 d5 00 	lds	r24, 0x00D5
 6a2:	81 fd       	sbrc	r24, 1
 6a4:	0b c1       	rjmp	.+534    	; 0x8bc <main+0x30e>
			last_buttons[RE_BB_12] =buttons[RE_BB_12];

			gFlags &= ~ROTENC_POLL;
		}

		if (gFlags & BUTTON_POLL)
 6a6:	80 91 d5 00 	lds	r24, 0x00D5
 6aa:	80 ff       	sbrs	r24, 0
 6ac:	f9 c0       	rjmp	.+498    	; 0x8a0 <main+0x2f2>
			for (int i =0; i < 5; i++)
			{
				// read button state byte from I/O expander
				// address byte - Bit7:1 = slave address
				//				  Bit0	 = R/W bit
				twi_buf[0] = ((0x20 + i)<<1)|0x1;
 6ae:	99 82       	std	Y+1, r9	; 0x01
				twi_buf[1] =0;
 6b0:	1a 82       	std	Y+2, r1	; 0x02

				TWI_Start_Transceiver_With_Data(&twi_buf[0], 2);
 6b2:	c6 01       	movw	r24, r12
 6b4:	62 e0       	ldi	r22, 0x02	; 2
 6b6:	27 d3       	rcall	.+1614   	; 0xd06 <TWI_Start_Transceiver_With_Data>
				TWI_Get_Data_From_Transceiver(&twi_buf[0], 2);
 6b8:	c6 01       	movw	r24, r12
 6ba:	62 e0       	ldi	r22, 0x02	; 2
 6bc:	53 d3       	rcall	.+1702   	; 0xd64 <TWI_Get_Data_From_Transceiver>

				// parse button states received from port expanders
				uint8_t b = ~twi_buf[1];
 6be:	8a 81       	ldd	r24, Y+2	; 0x02
 6c0:	80 95       	com	r24
 6c2:	00 e0       	ldi	r16, 0x00	; 0
 6c4:	10 e0       	ldi	r17, 0x00	; 0

				// mask out LED bit
				if (i ==SEL_LED && (b & SEL_LED_ON))
					b &= ~SEL_LED_ON;

				buttons[i] =b;
 6c6:	f8 01       	movw	r30, r16
 6c8:	e4 55       	subi	r30, 0x54	; 84
 6ca:	ff 4f       	sbci	r31, 0xFF	; 255
 6cc:	80 83       	st	Z, r24
		}

		if (gFlags & BUTTON_POLL)
		{
			// read buttons via TWI
			for (int i =0; i < 5; i++)
 6ce:	0f 5f       	subi	r16, 0xFF	; 255
 6d0:	1f 4f       	sbci	r17, 0xFF	; 255
 6d2:	05 30       	cpi	r16, 0x05	; 5
 6d4:	11 05       	cpc	r17, r1
 6d6:	bc f4       	brge	.+46     	; 0x706 <main+0x158>
			{
				// read button state byte from I/O expander
				// address byte - Bit7:1 = slave address
				//				  Bit0	 = R/W bit
				twi_buf[0] = ((0x20 + i)<<1)|0x1;
 6d8:	c8 01       	movw	r24, r16
 6da:	80 96       	adiw	r24, 0x20	; 32
 6dc:	88 0f       	add	r24, r24
 6de:	99 1f       	adc	r25, r25
 6e0:	81 60       	ori	r24, 0x01	; 1
 6e2:	89 83       	std	Y+1, r24	; 0x01
				twi_buf[1] =0;
 6e4:	1a 82       	std	Y+2, r1	; 0x02

				TWI_Start_Transceiver_With_Data(&twi_buf[0], 2);
 6e6:	c6 01       	movw	r24, r12
 6e8:	62 e0       	ldi	r22, 0x02	; 2
 6ea:	0d d3       	rcall	.+1562   	; 0xd06 <TWI_Start_Transceiver_With_Data>
				TWI_Get_Data_From_Transceiver(&twi_buf[0], 2);
 6ec:	c6 01       	movw	r24, r12
 6ee:	62 e0       	ldi	r22, 0x02	; 2
 6f0:	39 d3       	rcall	.+1650   	; 0xd64 <TWI_Get_Data_From_Transceiver>

				// parse button states received from port expanders
				uint8_t b = ~twi_buf[1];
 6f2:	8a 81       	ldd	r24, Y+2	; 0x02
 6f4:	80 95       	com	r24

				// mask out LED bit
				if (i ==SEL_LED && (b & SEL_LED_ON))
 6f6:	04 30       	cpi	r16, 0x04	; 4
 6f8:	11 05       	cpc	r17, r1
 6fa:	29 f7       	brne	.-54     	; 0x6c6 <main+0x118>
 6fc:	86 ff       	sbrs	r24, 6
 6fe:	e3 cf       	rjmp	.-58     	; 0x6c6 <main+0x118>
					b &= ~SEL_LED_ON;
 700:	8f 7b       	andi	r24, 0xBF	; 191

				buttons[i] =b;
 702:	80 93 b0 00 	sts	0x00B0, r24

			}

			if (buttons[PB9_16] & _BV(5)) { // flip switch is on
 706:	80 91 ad 00 	lds	r24, 0x00AD
 70a:	85 ff       	sbrs	r24, 5
 70c:	6a c1       	rjmp	.+724    	; 0x9e2 <main+0x434>
				if (!(lastRotSw_2 & _BV(BT14))) { // and was off
 70e:	80 91 cd 00 	lds	r24, 0x00CD
 712:	87 fd       	sbrc	r24, 7
 714:	24 c2       	rjmp	.+1096   	; 0xb5e <main+0x5b0>
					lastRotSw_2 |= _BV(BT14); // flip switch stays on (to send pulse to PC
 716:	80 91 cd 00 	lds	r24, 0x00CD
 71a:	80 68       	ori	r24, 0x80	; 128
 71c:	80 93 cd 00 	sts	0x00CD, r24
					lastRotSw_2 &= ~_BV(BT14);
				}
			}

			// Rotary Encoder1 push button pressed...
			if ( (buttons[RE_PB] & 0x80) &&
 720:	80 91 af 00 	lds	r24, 0x00AF
 724:	87 fd       	sbrc	r24, 7
 726:	6f c1       	rjmp	.+734    	; 0xa06 <main+0x458>
					// set LED status to OFF
					lastRotSw_2 &= ~SEL_LED_ON;
				}
			}

			RotSw_1 =(buttons[3] & 0xF);
 728:	80 91 af 00 	lds	r24, 0x00AF
 72c:	90 e0       	ldi	r25, 0x00	; 0
 72e:	8f 70       	andi	r24, 0x0F	; 15
 730:	90 70       	andi	r25, 0x00	; 0
 732:	90 93 d4 00 	sts	0x00D4, r25
 736:	80 93 d3 00 	sts	0x00D3, r24
			RotSw_1 <<=8;
 73a:	80 91 d3 00 	lds	r24, 0x00D3
 73e:	90 91 d4 00 	lds	r25, 0x00D4
 742:	98 2f       	mov	r25, r24
 744:	88 27       	eor	r24, r24
 746:	90 93 d4 00 	sts	0x00D4, r25
 74a:	80 93 d3 00 	sts	0x00D3, r24
			RotSw_1 |= buttons[2] & 0xFF;
 74e:	80 91 ae 00 	lds	r24, 0x00AE
 752:	20 91 d3 00 	lds	r18, 0x00D3
 756:	30 91 d4 00 	lds	r19, 0x00D4
 75a:	90 e0       	ldi	r25, 0x00	; 0
 75c:	82 2b       	or	r24, r18
 75e:	93 2b       	or	r25, r19
 760:	90 93 d4 00 	sts	0x00D4, r25
 764:	80 93 d3 00 	sts	0x00D3, r24

			// bit 7 of lastRotSw_1 is used for button 14
			// status; so clear low 6 bits first before
			// assigning new value
			RotSw_2 &= ~0x3F;
 768:	80 91 c8 00 	lds	r24, 0x00C8
 76c:	80 7c       	andi	r24, 0xC0	; 192
 76e:	80 93 c8 00 	sts	0x00C8, r24
			RotSw_2 |= (buttons[RS2_1_6] & 0x3F);
 772:	80 91 b0 00 	lds	r24, 0x00B0
 776:	90 91 c8 00 	lds	r25, 0x00C8
 77a:	8f 73       	andi	r24, 0x3F	; 63
 77c:	89 2b       	or	r24, r25
 77e:	80 93 c8 00 	sts	0x00C8, r24


			if (lastRotSw_1 ==RotSw_1) {
 782:	20 91 ce 00 	lds	r18, 0x00CE
 786:	30 91 cf 00 	lds	r19, 0x00CF
 78a:	80 91 d3 00 	lds	r24, 0x00D3
 78e:	90 91 d4 00 	lds	r25, 0x00D4
 792:	28 17       	cp	r18, r24
 794:	39 07       	cpc	r19, r25
 796:	09 f4       	brne	.+2      	; 0x79a <main+0x1ec>
 798:	82 c1       	rjmp	.+772    	; 0xa9e <main+0x4f0>
					buttons[RS1_9_12] &= ~_BV(2);
				else if (RotSw_1 & RS1_12)
					buttons[RS1_9_12] &= ~_BV(3);
			}
			else {
				lastRotSw_1 =RotSw_1;
 79a:	80 91 d3 00 	lds	r24, 0x00D3
 79e:	90 91 d4 00 	lds	r25, 0x00D4
 7a2:	90 93 cf 00 	sts	0x00CF, r25
 7a6:	80 93 ce 00 	sts	0x00CE, r24
			}

			if ( (lastRotSw_2 & 0x3F) ==RotSw_2) {
 7aa:	80 91 cd 00 	lds	r24, 0x00CD
 7ae:	20 91 c8 00 	lds	r18, 0x00C8
 7b2:	90 e0       	ldi	r25, 0x00	; 0
 7b4:	8f 73       	andi	r24, 0x3F	; 63
 7b6:	90 70       	andi	r25, 0x00	; 0
 7b8:	30 e0       	ldi	r19, 0x00	; 0
 7ba:	82 17       	cp	r24, r18
 7bc:	93 07       	cpc	r25, r19
 7be:	09 f4       	brne	.+2      	; 0x7c2 <main+0x214>
 7c0:	56 c1       	rjmp	.+684    	; 0xa6e <main+0x4c0>
					buttons[RS2_1_6] &= ~_BV(4);
				else if (RotSw_2 & RS2_6)
					buttons[RS2_1_6] &= ~_BV(5);
			}
			else {
				lastRotSw_2 &= ~0x3F;
 7c2:	80 91 cd 00 	lds	r24, 0x00CD
 7c6:	80 7c       	andi	r24, 0xC0	; 192
 7c8:	80 93 cd 00 	sts	0x00CD, r24
				lastRotSw_2 |= RotSw_2;
 7cc:	90 91 cd 00 	lds	r25, 0x00CD
 7d0:	80 91 c8 00 	lds	r24, 0x00C8
 7d4:	89 2b       	or	r24, r25
 7d6:	80 93 cd 00 	sts	0x00CD, r24
			}


			// mask bits that should not arrive PC
			if (buttons[RE_PB] & 0x80) {
 7da:	80 91 af 00 	lds	r24, 0x00AF
 7de:	87 fd       	sbrc	r24, 7
 7e0:	53 c1       	rjmp	.+678    	; 0xa88 <main+0x4da>
				buttons[RE_PB] &= ~0x80;
				gFlags |= SEL_BT;
			}
			else
				gFlags &= ~SEL_BT;
 7e2:	80 91 d5 00 	lds	r24, 0x00D5
 7e6:	87 7f       	andi	r24, 0xF7	; 247
 7e8:	80 93 d5 00 	sts	0x00D5, r24

			// check if buttons have changed since last poll
			for (uint8_t i =0; i < BUTTON_STATE_LEN; i++) {

				if (buttons[i] !=last_buttons[i])
 7ec:	90 91 ac 00 	lds	r25, 0x00AC
 7f0:	80 91 b2 00 	lds	r24, 0x00B2
 7f4:	98 17       	cp	r25, r24
 7f6:	29 f0       	breq	.+10     	; 0x802 <main+0x254>
					gFlags |=BUTTON_UPDATE;
 7f8:	80 91 d5 00 	lds	r24, 0x00D5
 7fc:	84 60       	ori	r24, 0x04	; 4
 7fe:	80 93 d5 00 	sts	0x00D5, r24
				last_buttons[i] =buttons[i];
 802:	80 91 ac 00 	lds	r24, 0x00AC
 806:	80 93 b2 00 	sts	0x00B2, r24
				gFlags &= ~SEL_BT;

			// check if buttons have changed since last poll
			for (uint8_t i =0; i < BUTTON_STATE_LEN; i++) {

				if (buttons[i] !=last_buttons[i])
 80a:	90 91 ad 00 	lds	r25, 0x00AD
 80e:	80 91 b3 00 	lds	r24, 0x00B3
 812:	98 17       	cp	r25, r24
 814:	29 f0       	breq	.+10     	; 0x820 <main+0x272>
					gFlags |=BUTTON_UPDATE;
 816:	80 91 d5 00 	lds	r24, 0x00D5
 81a:	84 60       	ori	r24, 0x04	; 4
 81c:	80 93 d5 00 	sts	0x00D5, r24
				last_buttons[i] =buttons[i];
 820:	80 91 ad 00 	lds	r24, 0x00AD
 824:	80 93 b3 00 	sts	0x00B3, r24
				gFlags &= ~SEL_BT;

			// check if buttons have changed since last poll
			for (uint8_t i =0; i < BUTTON_STATE_LEN; i++) {

				if (buttons[i] !=last_buttons[i])
 828:	90 91 ae 00 	lds	r25, 0x00AE
 82c:	80 91 b4 00 	lds	r24, 0x00B4
 830:	98 17       	cp	r25, r24
 832:	29 f0       	breq	.+10     	; 0x83e <main+0x290>
					gFlags |=BUTTON_UPDATE;
 834:	80 91 d5 00 	lds	r24, 0x00D5
 838:	84 60       	ori	r24, 0x04	; 4
 83a:	80 93 d5 00 	sts	0x00D5, r24
				last_buttons[i] =buttons[i];
 83e:	80 91 ae 00 	lds	r24, 0x00AE
 842:	80 93 b4 00 	sts	0x00B4, r24
				gFlags &= ~SEL_BT;

			// check if buttons have changed since last poll
			for (uint8_t i =0; i < BUTTON_STATE_LEN; i++) {

				if (buttons[i] !=last_buttons[i])
 846:	90 91 af 00 	lds	r25, 0x00AF
 84a:	80 91 b5 00 	lds	r24, 0x00B5
 84e:	98 17       	cp	r25, r24
 850:	29 f0       	breq	.+10     	; 0x85c <main+0x2ae>
					gFlags |=BUTTON_UPDATE;
 852:	80 91 d5 00 	lds	r24, 0x00D5
 856:	84 60       	ori	r24, 0x04	; 4
 858:	80 93 d5 00 	sts	0x00D5, r24
				last_buttons[i] =buttons[i];
 85c:	80 91 af 00 	lds	r24, 0x00AF
 860:	80 93 b5 00 	sts	0x00B5, r24
				gFlags &= ~SEL_BT;

			// check if buttons have changed since last poll
			for (uint8_t i =0; i < BUTTON_STATE_LEN; i++) {

				if (buttons[i] !=last_buttons[i])
 864:	90 91 b0 00 	lds	r25, 0x00B0
 868:	80 91 b6 00 	lds	r24, 0x00B6
 86c:	98 17       	cp	r25, r24
 86e:	29 f0       	breq	.+10     	; 0x87a <main+0x2cc>
					gFlags |=BUTTON_UPDATE;
 870:	80 91 d5 00 	lds	r24, 0x00D5
 874:	84 60       	ori	r24, 0x04	; 4
 876:	80 93 d5 00 	sts	0x00D5, r24
				last_buttons[i] =buttons[i];
 87a:	80 91 b0 00 	lds	r24, 0x00B0
 87e:	80 93 b6 00 	sts	0x00B6, r24
				gFlags &= ~SEL_BT;

			// check if buttons have changed since last poll
			for (uint8_t i =0; i < BUTTON_STATE_LEN; i++) {

				if (buttons[i] !=last_buttons[i])
 882:	90 91 b1 00 	lds	r25, 0x00B1
 886:	80 91 b7 00 	lds	r24, 0x00B7
 88a:	98 17       	cp	r25, r24
 88c:	29 f0       	breq	.+10     	; 0x898 <main+0x2ea>
					gFlags |=BUTTON_UPDATE;
 88e:	80 91 d5 00 	lds	r24, 0x00D5
 892:	84 60       	ori	r24, 0x04	; 4
 894:	80 93 d5 00 	sts	0x00D5, r24
				last_buttons[i] =buttons[i];
 898:	80 91 b1 00 	lds	r24, 0x00B1
 89c:	80 93 b7 00 	sts	0x00B7, r24

		}

		// hold transmission of data to PC when DTR flag is clear
		//if ( ((gFlags & GF_DTR) ==GF_DTR) ){
		if (!(PIND & _BV(DTR))) {
 8a0:	82 99       	sbic	0x10, 2	; 16
 8a2:	04 c0       	rjmp	.+8      	; 0x8ac <main+0x2fe>
			if ((gFlags & BUTTON_UPDATE) ==BUTTON_UPDATE) {
 8a4:	80 91 d5 00 	lds	r24, 0x00D5
 8a8:	82 fd       	sbrc	r24, 2
 8aa:	c2 c0       	rjmp	.+388    	; 0xa30 <main+0x482>

				gFlags &= ~BUTTON_UPDATE;
			}
		}

		proto_cc =0;
 8ac:	10 92 d7 00 	sts	0x00D7, r1
		gFlags &= ~BUTTON_POLL;
 8b0:	80 91 d5 00 	lds	r24, 0x00D5
 8b4:	8e 7f       	andi	r24, 0xFE	; 254
 8b6:	80 93 d5 00 	sts	0x00D5, r24
 8ba:	b6 ce       	rjmp	.-660    	; 0x628 <main+0x7a>
{
	// clear old encoder values
	//buttons[RE_BB_12] =0;

	/*** BRAKE BIAS encoder ***/
	if (!RENC_BB_PINA)
 8bc:	b2 99       	sbic	0x16, 2	; 22
 8be:	05 c0       	rjmp	.+10     	; 0x8ca <main+0x31c>
		renc_bb_status |=2;
 8c0:	80 91 c3 00 	lds	r24, 0x00C3
 8c4:	82 60       	ori	r24, 0x02	; 2
 8c6:	80 93 c3 00 	sts	0x00C3, r24
	if (!RENC_BB_PINB)
 8ca:	87 99       	sbic	0x10, 7	; 16
 8cc:	05 c0       	rjmp	.+10     	; 0x8d8 <main+0x32a>
		renc_bb_status |=1;
 8ce:	80 91 c3 00 	lds	r24, 0x00C3
 8d2:	81 60       	ori	r24, 0x01	; 1
 8d4:	80 93 c3 00 	sts	0x00C3, r24

	if ((renc_bb_status & 0xC) ==0xC) {
 8d8:	80 91 c3 00 	lds	r24, 0x00C3
 8dc:	8c 70       	andi	r24, 0x0C	; 12
 8de:	8c 30       	cpi	r24, 0x0C	; 12
 8e0:	09 f4       	brne	.+2      	; 0x8e4 <main+0x336>
 8e2:	11 c1       	rjmp	.+546    	; 0xb06 <main+0x558>
		else if (renc_bb_status ==2) {
			buttons[RE_BB_12] =0x80;
			//			gFlags |= BUTTON_UPDATE;
		}
	}
	renc_bb_status =(renc_bb_status << 2) & 0xF;
 8e4:	80 91 c3 00 	lds	r24, 0x00C3
 8e8:	88 0f       	add	r24, r24
 8ea:	88 0f       	add	r24, r24
 8ec:	8c 70       	andi	r24, 0x0C	; 12
 8ee:	80 93 c3 00 	sts	0x00C3, r24
	/***	***/

	/*** selection encoder 1 ***/
	if (!RENC_SEL1_PINA)
 8f2:	86 99       	sbic	0x10, 6	; 16
 8f4:	05 c0       	rjmp	.+10     	; 0x900 <main+0x352>
		renc_sel1_status |=2;
 8f6:	80 91 cc 00 	lds	r24, 0x00CC
 8fa:	82 60       	ori	r24, 0x02	; 2
 8fc:	80 93 cc 00 	sts	0x00CC, r24
	if (!RENC_SEL1_PINB)
 900:	85 99       	sbic	0x10, 5	; 16
 902:	05 c0       	rjmp	.+10     	; 0x90e <main+0x360>
		renc_sel1_status |=1;
 904:	80 91 cc 00 	lds	r24, 0x00CC
 908:	81 60       	ori	r24, 0x01	; 1
 90a:	80 93 cc 00 	sts	0x00CC, r24

	if ((renc_sel1_status & 0xC) ==0xC) {
 90e:	80 91 cc 00 	lds	r24, 0x00CC
 912:	8c 70       	andi	r24, 0x0C	; 12
 914:	8c 30       	cpi	r24, 0x0C	; 12
 916:	09 f4       	brne	.+2      	; 0x91a <main+0x36c>
 918:	e0 c0       	rjmp	.+448    	; 0xada <main+0x52c>
				buttons[RE_BB_12] =0x2;
				//				gFlags |= BUTTON_UPDATE;
			}
		}
	}
	renc_sel1_status = (renc_sel1_status << 2) & 0xF;
 91a:	80 91 cc 00 	lds	r24, 0x00CC
 91e:	88 0f       	add	r24, r24
 920:	88 0f       	add	r24, r24
 922:	8c 70       	andi	r24, 0x0C	; 12
 924:	80 93 cc 00 	sts	0x00CC, r24
	/***	***/

	/*** selection encoder 2 ***/
	if (!RENC_SEL2_PINA)
 928:	9a 99       	sbic	0x13, 2	; 19
 92a:	05 c0       	rjmp	.+10     	; 0x936 <main+0x388>
		renc_sel2_status |=2;
 92c:	80 91 c6 00 	lds	r24, 0x00C6
 930:	82 60       	ori	r24, 0x02	; 2
 932:	80 93 c6 00 	sts	0x00C6, r24
	if (!RENC_SEL2_PINB)
 936:	9b 99       	sbic	0x13, 3	; 19
 938:	05 c0       	rjmp	.+10     	; 0x944 <main+0x396>
		renc_sel2_status |=1;
 93a:	80 91 c6 00 	lds	r24, 0x00C6
 93e:	81 60       	ori	r24, 0x01	; 1
 940:	80 93 c6 00 	sts	0x00C6, r24

	if ((renc_sel2_status & 0xC) ==0xC) {
 944:	80 91 c6 00 	lds	r24, 0x00C6
 948:	8c 70       	andi	r24, 0x0C	; 12
 94a:	8c 30       	cpi	r24, 0x0C	; 12
 94c:	09 f4       	brne	.+2      	; 0x950 <main+0x3a2>
 94e:	b3 c0       	rjmp	.+358    	; 0xab6 <main+0x508>
		else if (renc_sel2_status ==2) {
			buttons[RE_BB_12] =0x8;
			//			gFlags |= BUTTON_UPDATE;
		}
	}
	renc_sel2_status = (renc_sel2_status << 2) & 0xF;
 950:	80 91 c6 00 	lds	r24, 0x00C6
 954:	88 0f       	add	r24, r24
 956:	88 0f       	add	r24, r24
 958:	8c 70       	andi	r24, 0x0C	; 12
 95a:	80 93 c6 00 	sts	0x00C6, r24
					}
				}
			}
#endif

			if (last_buttons[RE_BB_12] !=buttons[RE_BB_12])
 95e:	90 91 b7 00 	lds	r25, 0x00B7
 962:	80 91 b1 00 	lds	r24, 0x00B1
 966:	98 17       	cp	r25, r24
 968:	29 f0       	breq	.+10     	; 0x974 <main+0x3c6>
				gFlags |=BUTTON_UPDATE;
 96a:	80 91 d5 00 	lds	r24, 0x00D5
 96e:	84 60       	ori	r24, 0x04	; 4
 970:	80 93 d5 00 	sts	0x00D5, r24
			last_buttons[RE_BB_12] =buttons[RE_BB_12];
 974:	80 91 b1 00 	lds	r24, 0x00B1
 978:	80 93 b7 00 	sts	0x00B7, r24

			gFlags &= ~ROTENC_POLL;
 97c:	80 91 d5 00 	lds	r24, 0x00D5
 980:	8d 7f       	andi	r24, 0xFD	; 253
 982:	80 93 d5 00 	sts	0x00D5, r24
 986:	8f ce       	rjmp	.-738    	; 0x6a6 <main+0xf8>
		// MAX232 inverts the signal
//		while((PIND & _BV(DTR)));
//		gFlags |= GF_DTR;

		if (proto_cc ==0) {
			if (usart_avail() >= 1) {
 988:	db db       	rcall	.-2122   	; 0x140 <usart_avail>
 98a:	88 23       	and	r24, r24
 98c:	09 f0       	breq	.+2      	; 0x990 <main+0x3e2>
 98e:	cd c0       	rjmp	.+410    	; 0xb2a <main+0x57c>
				proto_cc =usart_getbyte();
			}

			// get length of protocol data
			len =(proto_cc & PROTO_LEN_MASK);
 990:	90 91 d7 00 	lds	r25, 0x00D7
 994:	19 2f       	mov	r17, r25
 996:	1f 70       	andi	r17, 0x0F	; 15

			// get protocol data
			if (len > 0 && len <=MAX_PAYLOAD_LEN) {
 998:	81 2f       	mov	r24, r17
 99a:	81 50       	subi	r24, 0x01	; 1
 99c:	8f 30       	cpi	r24, 0x0F	; 15
 99e:	50 f0       	brcs	.+20     	; 0x9b4 <main+0x406>
				for (int i =0; i < len; i++)
					proto_buf[i] =usart_getbyte();
			}

			// parse serial protocol cc byte
			if (proto_cc & PROTO_CONFIG) {
 9a0:	96 ff       	sbrs	r25, 6
 9a2:	7d ce       	rjmp	.-774    	; 0x69e <main+0xf0>
// update_config();
void update_config(uint8_t cc, uint8_t* buf, uint8_t len)
{
	if (buf !=NULL) {

		if (buf[0] =='L') { // update LED brightness sub-command
 9a4:	8d 81       	ldd	r24, Y+5	; 0x05
 9a6:	8c 34       	cpi	r24, 0x4C	; 76
 9a8:	09 f0       	breq	.+2      	; 0x9ac <main+0x3fe>
 9aa:	79 ce       	rjmp	.-782    	; 0x69e <main+0xf0>

			// set PWM duty cycle here to dim blue LEDs
			pwm_dc =buf[1];
 9ac:	8e 81       	ldd	r24, Y+6	; 0x06
 9ae:	80 93 d2 00 	sts	0x00D2, r24
 9b2:	75 ce       	rjmp	.-790    	; 0x69e <main+0xf0>
			len =(proto_cc & PROTO_LEN_MASK);

			// get protocol data
			if (len > 0 && len <=MAX_PAYLOAD_LEN) {
				// wait until len bytes arrived
				while (usart_avail() < len);
 9b4:	c5 db       	rcall	.-2166   	; 0x140 <usart_avail>
 9b6:	81 17       	cp	r24, r17
 9b8:	e8 f3       	brcs	.-6      	; 0x9b4 <main+0x406>
				for (int i =0; i < len; i++)
 9ba:	e1 2e       	mov	r14, r17
 9bc:	ff 24       	eor	r15, r15
 9be:	e1 14       	cp	r14, r1
 9c0:	f1 04       	cpc	r15, r1
 9c2:	61 f0       	breq	.+24     	; 0x9dc <main+0x42e>
 9c4:	00 e0       	ldi	r16, 0x00	; 0
 9c6:	10 e0       	ldi	r17, 0x00	; 0
					proto_buf[i] =usart_getbyte();
 9c8:	be db       	rcall	.-2180   	; 0x146 <usart_getbyte>
 9ca:	f5 01       	movw	r30, r10
 9cc:	e0 0f       	add	r30, r16
 9ce:	f1 1f       	adc	r31, r17
 9d0:	80 83       	st	Z, r24

			// get protocol data
			if (len > 0 && len <=MAX_PAYLOAD_LEN) {
				// wait until len bytes arrived
				while (usart_avail() < len);
				for (int i =0; i < len; i++)
 9d2:	0f 5f       	subi	r16, 0xFF	; 255
 9d4:	1f 4f       	sbci	r17, 0xFF	; 255
 9d6:	0e 15       	cp	r16, r14
 9d8:	1f 05       	cpc	r17, r15
 9da:	b4 f3       	brlt	.-20     	; 0x9c8 <main+0x41a>
 9dc:	90 91 d7 00 	lds	r25, 0x00D7
 9e0:	df cf       	rjmp	.-66     	; 0x9a0 <main+0x3f2>
				else { // and was on
					buttons[PB9_16] &= ~_BV(5); // clear button flag to prvent sending another pulse to PC
				}
			}
			else { // flip switch is off
				if (lastRotSw_2 & _BV(BT14)) { // and was on
 9e2:	80 91 cd 00 	lds	r24, 0x00CD
 9e6:	87 ff       	sbrs	r24, 7
 9e8:	9b ce       	rjmp	.-714    	; 0x720 <main+0x172>
					// send new pulse
					buttons[PB9_16] |= _BV(5);
 9ea:	80 91 ad 00 	lds	r24, 0x00AD
 9ee:	80 62       	ori	r24, 0x20	; 32
 9f0:	80 93 ad 00 	sts	0x00AD, r24
					lastRotSw_2 &= ~_BV(BT14);
 9f4:	80 91 cd 00 	lds	r24, 0x00CD
 9f8:	8f 77       	andi	r24, 0x7F	; 127
 9fa:	80 93 cd 00 	sts	0x00CD, r24
				}
			}

			// Rotary Encoder1 push button pressed...
			if ( (buttons[RE_PB] & 0x80) &&
 9fe:	80 91 af 00 	lds	r24, 0x00AF
 a02:	87 ff       	sbrs	r24, 7
 a04:	91 ce       	rjmp	.-734    	; 0x728 <main+0x17a>
 a06:	80 91 d5 00 	lds	r24, 0x00D5
 a0a:	83 fd       	sbrc	r24, 3
 a0c:	8d ce       	rjmp	.-742    	; 0x728 <main+0x17a>
					(!(gFlags & SEL_BT)) ) {
				// and LED status OFF...
				if (!(lastRotSw_2 & SEL_LED_ON)) {
 a0e:	80 91 cd 00 	lds	r24, 0x00CD
 a12:	86 fd       	sbrc	r24, 6
 a14:	c0 c0       	rjmp	.+384    	; 0xb96 <main+0x5e8>
					// ...enable selector LED (yellow)
					uint8_t led[2] ={(0x24<<1) | 0x0, ~0x40};
 a16:	88 e4       	ldi	r24, 0x48	; 72
 a18:	8b 83       	std	Y+3, r24	; 0x03
 a1a:	ef eb       	ldi	r30, 0xBF	; 191
 a1c:	ec 83       	std	Y+4, r30	; 0x04
					TWI_Start_Transceiver_With_Data(led, 2);
 a1e:	c3 01       	movw	r24, r6
 a20:	62 e0       	ldi	r22, 0x02	; 2
 a22:	71 d1       	rcall	.+738    	; 0xd06 <TWI_Start_Transceiver_With_Data>

					// set LED status to ON
					lastRotSw_2 |= SEL_LED_ON;
 a24:	80 91 cd 00 	lds	r24, 0x00CD
 a28:	80 64       	ori	r24, 0x40	; 64
 a2a:	80 93 cd 00 	sts	0x00CD, r24
 a2e:	7c ce       	rjmp	.-776    	; 0x728 <main+0x17a>
		// hold transmission of data to PC when DTR flag is clear
		//if ( ((gFlags & GF_DTR) ==GF_DTR) ){
		if (!(PIND & _BV(DTR))) {
			if ((gFlags & BUTTON_UPDATE) ==BUTTON_UPDATE) {
				// send buttons state array to PC
				proto_cc =PROTO_SEND | (BUTTON_STATE_LEN & PROTO_LEN_MASK);
 a30:	e6 e2       	ldi	r30, 0x26	; 38
 a32:	e0 93 d7 00 	sts	0x00D7, r30
				usart_send((uint8_t*)&proto_cc, 1);
 a36:	87 ed       	ldi	r24, 0xD7	; 215
 a38:	90 e0       	ldi	r25, 0x00	; 0
 a3a:	61 e0       	ldi	r22, 0x01	; 1
 a3c:	10 dc       	rcall	.-2016   	; 0x25e <usart_send>
				usart_send((uint8_t*)&buttons[0], BUTTON_STATE_LEN);
 a3e:	8c ea       	ldi	r24, 0xAC	; 172
 a40:	90 e0       	ldi	r25, 0x00	; 0
 a42:	66 e0       	ldi	r22, 0x06	; 6
 a44:	0c dc       	rcall	.-2024   	; 0x25e <usart_send>

				proto_cc =0;
 a46:	10 92 d7 00 	sts	0x00D7, r1
				for (int i=0; i<BUTTON_STATE_LEN; i++)
					buttons[i] =0;
 a4a:	10 92 ac 00 	sts	0x00AC, r1
 a4e:	10 92 ad 00 	sts	0x00AD, r1
 a52:	10 92 ae 00 	sts	0x00AE, r1
 a56:	10 92 af 00 	sts	0x00AF, r1
 a5a:	10 92 b0 00 	sts	0x00B0, r1
 a5e:	10 92 b1 00 	sts	0x00B1, r1

				gFlags &= ~BUTTON_UPDATE;
 a62:	80 91 d5 00 	lds	r24, 0x00D5
 a66:	8b 7f       	andi	r24, 0xFB	; 251
 a68:	80 93 d5 00 	sts	0x00D5, r24
 a6c:	1f cf       	rjmp	.-450    	; 0x8ac <main+0x2fe>
			else {
				lastRotSw_1 =RotSw_1;
			}

			if ( (lastRotSw_2 & 0x3F) ==RotSw_2) {
				if (RotSw_2 & RS2_1)
 a6e:	80 91 c8 00 	lds	r24, 0x00C8
 a72:	80 ff       	sbrs	r24, 0
 a74:	5e c0       	rjmp	.+188    	; 0xb32 <main+0x584>
					buttons[RS2_1_6] &= ~_BV(0);
 a76:	80 91 b0 00 	lds	r24, 0x00B0
 a7a:	8e 7f       	andi	r24, 0xFE	; 254
 a7c:	80 93 b0 00 	sts	0x00B0, r24
				lastRotSw_2 |= RotSw_2;
			}


			// mask bits that should not arrive PC
			if (buttons[RE_PB] & 0x80) {
 a80:	80 91 af 00 	lds	r24, 0x00AF
 a84:	87 ff       	sbrs	r24, 7
 a86:	ad ce       	rjmp	.-678    	; 0x7e2 <main+0x234>
				buttons[RE_PB] &= ~0x80;
 a88:	80 91 af 00 	lds	r24, 0x00AF
 a8c:	8f 77       	andi	r24, 0x7F	; 127
 a8e:	80 93 af 00 	sts	0x00AF, r24
				gFlags |= SEL_BT;
 a92:	80 91 d5 00 	lds	r24, 0x00D5
 a96:	88 60       	ori	r24, 0x08	; 8
 a98:	80 93 d5 00 	sts	0x00D5, r24
 a9c:	a7 ce       	rjmp	.-690    	; 0x7ec <main+0x23e>
			RotSw_2 &= ~0x3F;
			RotSw_2 |= (buttons[RS2_1_6] & 0x3F);


			if (lastRotSw_1 ==RotSw_1) {
				if (RotSw_1 & RS1_1)
 a9e:	80 91 d3 00 	lds	r24, 0x00D3
 aa2:	90 91 d4 00 	lds	r25, 0x00D4
 aa6:	80 ff       	sbrs	r24, 0
 aa8:	4e c0       	rjmp	.+156    	; 0xb46 <main+0x598>
					buttons[RS1_1_8] &= ~_BV(0);
 aaa:	80 91 ae 00 	lds	r24, 0x00AE
 aae:	8e 7f       	andi	r24, 0xFE	; 254
 ab0:	80 93 ae 00 	sts	0x00AE, r24
 ab4:	7a ce       	rjmp	.-780    	; 0x7aa <main+0x1fc>
		renc_sel2_status |=2;
	if (!RENC_SEL2_PINB)
		renc_sel2_status |=1;

	if ((renc_sel2_status & 0xC) ==0xC) {
		renc_sel2_status &= 3;
 ab6:	80 91 c6 00 	lds	r24, 0x00C6
 aba:	83 70       	andi	r24, 0x03	; 3
 abc:	80 93 c6 00 	sts	0x00C6, r24

		if (renc_sel2_status ==1) {
 ac0:	80 91 c6 00 	lds	r24, 0x00C6
 ac4:	81 30       	cpi	r24, 0x01	; 1
 ac6:	09 f4       	brne	.+2      	; 0xaca <main+0x51c>
 ac8:	73 c0       	rjmp	.+230    	; 0xbb0 <main+0x602>
			buttons[RE_BB_12] =0x4;
			//			gFlags |= BUTTON_UPDATE;
		}
		else if (renc_sel2_status ==2) {
 aca:	80 91 c6 00 	lds	r24, 0x00C6
 ace:	82 30       	cpi	r24, 0x02	; 2
 ad0:	09 f0       	breq	.+2      	; 0xad4 <main+0x526>
 ad2:	3e cf       	rjmp	.-388    	; 0x950 <main+0x3a2>
			buttons[RE_BB_12] =0x8;
 ad4:	80 92 b1 00 	sts	0x00B1, r8
 ad8:	3b cf       	rjmp	.-394    	; 0x950 <main+0x3a2>
		renc_sel1_status |=2;
	if (!RENC_SEL1_PINB)
		renc_sel1_status |=1;

	if ((renc_sel1_status & 0xC) ==0xC) {
		renc_sel1_status &= 3;
 ada:	80 91 cc 00 	lds	r24, 0x00CC
 ade:	83 70       	andi	r24, 0x03	; 3
 ae0:	80 93 cc 00 	sts	0x00CC, r24

		if (renc_sel1_status ==1) {
 ae4:	90 91 cc 00 	lds	r25, 0x00CC
 ae8:	91 30       	cpi	r25, 0x01	; 1
 aea:	09 f4       	brne	.+2      	; 0xaee <main+0x540>
 aec:	64 c0       	rjmp	.+200    	; 0xbb6 <main+0x608>
			else {
				buttons[RE_BB_12] =0x1;
				//				gFlags |= BUTTON_UPDATE;
			}
		}
		else if (renc_sel1_status ==2) {
 aee:	90 91 cc 00 	lds	r25, 0x00CC
 af2:	92 30       	cpi	r25, 0x02	; 2
 af4:	09 f0       	breq	.+2      	; 0xaf8 <main+0x54a>
 af6:	11 cf       	rjmp	.-478    	; 0x91a <main+0x36c>
			if (lastRotSw_2 & SEL_LED_ON) {
 af8:	80 91 cd 00 	lds	r24, 0x00CD
 afc:	86 ff       	sbrs	r24, 6
 afe:	66 c0       	rjmp	.+204    	; 0xbcc <main+0x61e>
				buttons[RE_BB_12] =0x20;
 b00:	40 92 b1 00 	sts	0x00B1, r4
 b04:	0a cf       	rjmp	.-492    	; 0x91a <main+0x36c>
		renc_bb_status |=2;
	if (!RENC_BB_PINB)
		renc_bb_status |=1;

	if ((renc_bb_status & 0xC) ==0xC) {
		renc_bb_status &= 3;
 b06:	80 91 c3 00 	lds	r24, 0x00C3
 b0a:	83 70       	andi	r24, 0x03	; 3
 b0c:	80 93 c3 00 	sts	0x00C3, r24

		if (renc_bb_status == 1) {
 b10:	80 91 c3 00 	lds	r24, 0x00C3
 b14:	81 30       	cpi	r24, 0x01	; 1
 b16:	09 f4       	brne	.+2      	; 0xb1a <main+0x56c>
 b18:	55 c0       	rjmp	.+170    	; 0xbc4 <main+0x616>
			buttons[RE_BB_12] =0x40;
			//			gFlags |= BUTTON_UPDATE;
		}
		else if (renc_bb_status ==2) {
 b1a:	80 91 c3 00 	lds	r24, 0x00C3
 b1e:	82 30       	cpi	r24, 0x02	; 2
 b20:	09 f0       	breq	.+2      	; 0xb24 <main+0x576>
 b22:	e0 ce       	rjmp	.-576    	; 0x8e4 <main+0x336>
			buttons[RE_BB_12] =0x80;
 b24:	20 92 b1 00 	sts	0x00B1, r2
 b28:	dd ce       	rjmp	.-582    	; 0x8e4 <main+0x336>
//		while((PIND & _BV(DTR)));
//		gFlags |= GF_DTR;

		if (proto_cc ==0) {
			if (usart_avail() >= 1) {
				proto_cc =usart_getbyte();
 b2a:	0d db       	rcall	.-2534   	; 0x146 <usart_getbyte>
 b2c:	80 93 d7 00 	sts	0x00D7, r24
 b30:	2f cf       	rjmp	.-418    	; 0x990 <main+0x3e2>
			}

			if ( (lastRotSw_2 & 0x3F) ==RotSw_2) {
				if (RotSw_2 & RS2_1)
					buttons[RS2_1_6] &= ~_BV(0);
				else if (RotSw_2 & RS2_2)
 b32:	80 91 c8 00 	lds	r24, 0x00C8
 b36:	81 ff       	sbrs	r24, 1
 b38:	18 c0       	rjmp	.+48     	; 0xb6a <main+0x5bc>
					buttons[RS2_1_6] &= ~_BV(1);
 b3a:	80 91 b0 00 	lds	r24, 0x00B0
 b3e:	8d 7f       	andi	r24, 0xFD	; 253
 b40:	80 93 b0 00 	sts	0x00B0, r24
 b44:	4a ce       	rjmp	.-876    	; 0x7da <main+0x22c>


			if (lastRotSw_1 ==RotSw_1) {
				if (RotSw_1 & RS1_1)
					buttons[RS1_1_8] &= ~_BV(0);
				else if (RotSw_1 & RS1_2)
 b46:	80 91 d3 00 	lds	r24, 0x00D3
 b4a:	90 91 d4 00 	lds	r25, 0x00D4
 b4e:	81 ff       	sbrs	r24, 1
 b50:	16 c0       	rjmp	.+44     	; 0xb7e <main+0x5d0>
					buttons[RS1_1_8] &= ~_BV(1);
 b52:	80 91 ae 00 	lds	r24, 0x00AE
 b56:	8d 7f       	andi	r24, 0xFD	; 253
 b58:	80 93 ae 00 	sts	0x00AE, r24
 b5c:	26 ce       	rjmp	.-948    	; 0x7aa <main+0x1fc>
				if (!(lastRotSw_2 & _BV(BT14))) { // and was off
					lastRotSw_2 |= _BV(BT14); // flip switch stays on (to send pulse to PC
					// and last state of switch is on
				}
				else { // and was on
					buttons[PB9_16] &= ~_BV(5); // clear button flag to prvent sending another pulse to PC
 b5e:	80 91 ad 00 	lds	r24, 0x00AD
 b62:	8f 7d       	andi	r24, 0xDF	; 223
 b64:	80 93 ad 00 	sts	0x00AD, r24
 b68:	db cd       	rjmp	.-1098   	; 0x720 <main+0x172>
			if ( (lastRotSw_2 & 0x3F) ==RotSw_2) {
				if (RotSw_2 & RS2_1)
					buttons[RS2_1_6] &= ~_BV(0);
				else if (RotSw_2 & RS2_2)
					buttons[RS2_1_6] &= ~_BV(1);
				else if (RotSw_2 & RS2_3)
 b6a:	80 91 c8 00 	lds	r24, 0x00C8
 b6e:	82 ff       	sbrs	r24, 2
 b70:	30 c0       	rjmp	.+96     	; 0xbd2 <main+0x624>
					buttons[RS2_1_6] &= ~_BV(2);
 b72:	80 91 b0 00 	lds	r24, 0x00B0
 b76:	8b 7f       	andi	r24, 0xFB	; 251
 b78:	80 93 b0 00 	sts	0x00B0, r24
 b7c:	2e ce       	rjmp	.-932    	; 0x7da <main+0x22c>
			if (lastRotSw_1 ==RotSw_1) {
				if (RotSw_1 & RS1_1)
					buttons[RS1_1_8] &= ~_BV(0);
				else if (RotSw_1 & RS1_2)
					buttons[RS1_1_8] &= ~_BV(1);
				else if (RotSw_1 & RS1_3)
 b7e:	80 91 d3 00 	lds	r24, 0x00D3
 b82:	90 91 d4 00 	lds	r25, 0x00D4
 b86:	82 ff       	sbrs	r24, 2
 b88:	2e c0       	rjmp	.+92     	; 0xbe6 <main+0x638>
					buttons[RS1_1_8] &= ~_BV(2);
 b8a:	80 91 ae 00 	lds	r24, 0x00AE
 b8e:	8b 7f       	andi	r24, 0xFB	; 251
 b90:	80 93 ae 00 	sts	0x00AE, r24
 b94:	0a ce       	rjmp	.-1004   	; 0x7aa <main+0x1fc>
					// set LED status to ON
					lastRotSw_2 |= SEL_LED_ON;
				}
				else {
					// disable LED
					uint8_t led[2] ={(0x24<<1) | 0x0, 0xFF};
 b96:	f8 e4       	ldi	r31, 0x48	; 72
 b98:	fb 83       	std	Y+3, r31	; 0x03
 b9a:	8f ef       	ldi	r24, 0xFF	; 255
 b9c:	8c 83       	std	Y+4, r24	; 0x04
					TWI_Start_Transceiver_With_Data(led, 2);
 b9e:	c3 01       	movw	r24, r6
 ba0:	62 e0       	ldi	r22, 0x02	; 2
 ba2:	b1 d0       	rcall	.+354    	; 0xd06 <TWI_Start_Transceiver_With_Data>

					// set LED status to OFF
					lastRotSw_2 &= ~SEL_LED_ON;
 ba4:	80 91 cd 00 	lds	r24, 0x00CD
 ba8:	8f 7b       	andi	r24, 0xBF	; 191
 baa:	80 93 cd 00 	sts	0x00CD, r24
 bae:	bc cd       	rjmp	.-1160   	; 0x728 <main+0x17a>

	if ((renc_sel2_status & 0xC) ==0xC) {
		renc_sel2_status &= 3;

		if (renc_sel2_status ==1) {
			buttons[RE_BB_12] =0x4;
 bb0:	50 92 b1 00 	sts	0x00B1, r5
 bb4:	cd ce       	rjmp	.-614    	; 0x950 <main+0x3a2>

	if ((renc_sel1_status & 0xC) ==0xC) {
		renc_sel1_status &= 3;

		if (renc_sel1_status ==1) {
			if (lastRotSw_2 & SEL_LED_ON) {
 bb6:	80 91 cd 00 	lds	r24, 0x00CD
 bba:	86 ff       	sbrs	r24, 6
 bbc:	07 c0       	rjmp	.+14     	; 0xbcc <main+0x61e>
				buttons[RE_BB_12] =0x10;
 bbe:	30 92 b1 00 	sts	0x00B1, r3
 bc2:	ab ce       	rjmp	.-682    	; 0x91a <main+0x36c>

	if ((renc_bb_status & 0xC) ==0xC) {
		renc_bb_status &= 3;

		if (renc_bb_status == 1) {
			buttons[RE_BB_12] =0x40;
 bc4:	f0 e4       	ldi	r31, 0x40	; 64
 bc6:	f0 93 b1 00 	sts	0x00B1, r31
 bca:	8c ce       	rjmp	.-744    	; 0x8e4 <main+0x336>
			if (lastRotSw_2 & SEL_LED_ON) {
				buttons[RE_BB_12] =0x20;
				//				gFlags |= BUTTON_UPDATE;
			}
			else {
				buttons[RE_BB_12] =0x2;
 bcc:	90 93 b1 00 	sts	0x00B1, r25
 bd0:	a4 ce       	rjmp	.-696    	; 0x91a <main+0x36c>
					buttons[RS2_1_6] &= ~_BV(0);
				else if (RotSw_2 & RS2_2)
					buttons[RS2_1_6] &= ~_BV(1);
				else if (RotSw_2 & RS2_3)
					buttons[RS2_1_6] &= ~_BV(2);
				else if (RotSw_2 & RS2_4)
 bd2:	80 91 c8 00 	lds	r24, 0x00C8
 bd6:	83 ff       	sbrs	r24, 3
 bd8:	12 c0       	rjmp	.+36     	; 0xbfe <main+0x650>
					buttons[RS2_1_6] &= ~_BV(3);
 bda:	80 91 b0 00 	lds	r24, 0x00B0
 bde:	87 7f       	andi	r24, 0xF7	; 247
 be0:	80 93 b0 00 	sts	0x00B0, r24
 be4:	fa cd       	rjmp	.-1036   	; 0x7da <main+0x22c>
					buttons[RS1_1_8] &= ~_BV(0);
				else if (RotSw_1 & RS1_2)
					buttons[RS1_1_8] &= ~_BV(1);
				else if (RotSw_1 & RS1_3)
					buttons[RS1_1_8] &= ~_BV(2);
				else if (RotSw_1 & RS1_4)
 be6:	80 91 d3 00 	lds	r24, 0x00D3
 bea:	90 91 d4 00 	lds	r25, 0x00D4
 bee:	83 ff       	sbrs	r24, 3
 bf0:	10 c0       	rjmp	.+32     	; 0xc12 <main+0x664>
					buttons[RS1_1_8] &= ~_BV(3);
 bf2:	80 91 ae 00 	lds	r24, 0x00AE
 bf6:	87 7f       	andi	r24, 0xF7	; 247
 bf8:	80 93 ae 00 	sts	0x00AE, r24
 bfc:	d6 cd       	rjmp	.-1108   	; 0x7aa <main+0x1fc>
					buttons[RS2_1_6] &= ~_BV(1);
				else if (RotSw_2 & RS2_3)
					buttons[RS2_1_6] &= ~_BV(2);
				else if (RotSw_2 & RS2_4)
					buttons[RS2_1_6] &= ~_BV(3);
				else if (RotSw_2 & RS2_5)
 bfe:	80 91 c8 00 	lds	r24, 0x00C8
 c02:	84 ff       	sbrs	r24, 4
 c04:	12 c0       	rjmp	.+36     	; 0xc2a <main+0x67c>
					buttons[RS2_1_6] &= ~_BV(4);
 c06:	80 91 b0 00 	lds	r24, 0x00B0
 c0a:	8f 7e       	andi	r24, 0xEF	; 239
 c0c:	80 93 b0 00 	sts	0x00B0, r24
 c10:	e4 cd       	rjmp	.-1080   	; 0x7da <main+0x22c>
					buttons[RS1_1_8] &= ~_BV(1);
				else if (RotSw_1 & RS1_3)
					buttons[RS1_1_8] &= ~_BV(2);
				else if (RotSw_1 & RS1_4)
					buttons[RS1_1_8] &= ~_BV(3);
				else if (RotSw_1 & RS1_5)
 c12:	80 91 d3 00 	lds	r24, 0x00D3
 c16:	90 91 d4 00 	lds	r25, 0x00D4
 c1a:	84 ff       	sbrs	r24, 4
 c1c:	10 c0       	rjmp	.+32     	; 0xc3e <main+0x690>
					buttons[RS1_1_8] &= ~_BV(4);
 c1e:	80 91 ae 00 	lds	r24, 0x00AE
 c22:	8f 7e       	andi	r24, 0xEF	; 239
 c24:	80 93 ae 00 	sts	0x00AE, r24
 c28:	c0 cd       	rjmp	.-1152   	; 0x7aa <main+0x1fc>
					buttons[RS2_1_6] &= ~_BV(2);
				else if (RotSw_2 & RS2_4)
					buttons[RS2_1_6] &= ~_BV(3);
				else if (RotSw_2 & RS2_5)
					buttons[RS2_1_6] &= ~_BV(4);
				else if (RotSw_2 & RS2_6)
 c2a:	80 91 c8 00 	lds	r24, 0x00C8
 c2e:	85 ff       	sbrs	r24, 5
 c30:	d4 cd       	rjmp	.-1112   	; 0x7da <main+0x22c>
					buttons[RS2_1_6] &= ~_BV(5);
 c32:	80 91 b0 00 	lds	r24, 0x00B0
 c36:	8f 7d       	andi	r24, 0xDF	; 223
 c38:	80 93 b0 00 	sts	0x00B0, r24
 c3c:	ce cd       	rjmp	.-1124   	; 0x7da <main+0x22c>
					buttons[RS1_1_8] &= ~_BV(2);
				else if (RotSw_1 & RS1_4)
					buttons[RS1_1_8] &= ~_BV(3);
				else if (RotSw_1 & RS1_5)
					buttons[RS1_1_8] &= ~_BV(4);
				else if (RotSw_1 & RS1_6)
 c3e:	80 91 d3 00 	lds	r24, 0x00D3
 c42:	90 91 d4 00 	lds	r25, 0x00D4
 c46:	85 ff       	sbrs	r24, 5
 c48:	06 c0       	rjmp	.+12     	; 0xc56 <main+0x6a8>
					buttons[RS1_1_8] &= ~_BV(5);
 c4a:	80 91 ae 00 	lds	r24, 0x00AE
 c4e:	8f 7d       	andi	r24, 0xDF	; 223
 c50:	80 93 ae 00 	sts	0x00AE, r24
 c54:	aa cd       	rjmp	.-1196   	; 0x7aa <main+0x1fc>
				else if (RotSw_1 & RS1_7)
 c56:	80 91 d3 00 	lds	r24, 0x00D3
 c5a:	90 91 d4 00 	lds	r25, 0x00D4
 c5e:	86 ff       	sbrs	r24, 6
 c60:	06 c0       	rjmp	.+12     	; 0xc6e <main+0x6c0>
					buttons[RS1_1_8] &= ~_BV(6);
 c62:	80 91 ae 00 	lds	r24, 0x00AE
 c66:	8f 7b       	andi	r24, 0xBF	; 191
 c68:	80 93 ae 00 	sts	0x00AE, r24
 c6c:	9e cd       	rjmp	.-1220   	; 0x7aa <main+0x1fc>
				else if (RotSw_1 & RS1_8)
 c6e:	80 91 d3 00 	lds	r24, 0x00D3
 c72:	90 91 d4 00 	lds	r25, 0x00D4
 c76:	87 ff       	sbrs	r24, 7
 c78:	06 c0       	rjmp	.+12     	; 0xc86 <main+0x6d8>
					buttons[RS1_1_8] &= ~_BV(7);
 c7a:	80 91 ae 00 	lds	r24, 0x00AE
 c7e:	8f 77       	andi	r24, 0x7F	; 127
 c80:	80 93 ae 00 	sts	0x00AE, r24
 c84:	92 cd       	rjmp	.-1244   	; 0x7aa <main+0x1fc>
				else if (RotSw_1 & RS1_9)
 c86:	80 91 d3 00 	lds	r24, 0x00D3
 c8a:	90 91 d4 00 	lds	r25, 0x00D4
 c8e:	90 ff       	sbrs	r25, 0
 c90:	06 c0       	rjmp	.+12     	; 0xc9e <main+0x6f0>
					buttons[RS1_9_12] &= ~_BV(0);
 c92:	80 91 af 00 	lds	r24, 0x00AF
 c96:	8e 7f       	andi	r24, 0xFE	; 254
 c98:	80 93 af 00 	sts	0x00AF, r24
 c9c:	86 cd       	rjmp	.-1268   	; 0x7aa <main+0x1fc>
				else if (RotSw_1 & RS1_10)
 c9e:	80 91 d3 00 	lds	r24, 0x00D3
 ca2:	90 91 d4 00 	lds	r25, 0x00D4
 ca6:	91 ff       	sbrs	r25, 1
 ca8:	06 c0       	rjmp	.+12     	; 0xcb6 <main+0x708>
					buttons[RS1_9_12] &= ~_BV(1);
 caa:	80 91 af 00 	lds	r24, 0x00AF
 cae:	8d 7f       	andi	r24, 0xFD	; 253
 cb0:	80 93 af 00 	sts	0x00AF, r24
 cb4:	7a cd       	rjmp	.-1292   	; 0x7aa <main+0x1fc>
				else if (RotSw_1 & RS1_11)
 cb6:	80 91 d3 00 	lds	r24, 0x00D3
 cba:	90 91 d4 00 	lds	r25, 0x00D4
 cbe:	92 ff       	sbrs	r25, 2
 cc0:	06 c0       	rjmp	.+12     	; 0xcce <main+0x720>
					buttons[RS1_9_12] &= ~_BV(2);
 cc2:	80 91 af 00 	lds	r24, 0x00AF
 cc6:	8b 7f       	andi	r24, 0xFB	; 251
 cc8:	80 93 af 00 	sts	0x00AF, r24
 ccc:	6e cd       	rjmp	.-1316   	; 0x7aa <main+0x1fc>
				else if (RotSw_1 & RS1_12)
 cce:	80 91 d3 00 	lds	r24, 0x00D3
 cd2:	90 91 d4 00 	lds	r25, 0x00D4
 cd6:	93 ff       	sbrs	r25, 3
 cd8:	68 cd       	rjmp	.-1328   	; 0x7aa <main+0x1fc>
					buttons[RS1_9_12] &= ~_BV(3);
 cda:	80 91 af 00 	lds	r24, 0x00AF
 cde:	87 7f       	andi	r24, 0xF7	; 247
 ce0:	80 93 af 00 	sts	0x00AF, r24
 ce4:	62 cd       	rjmp	.-1340   	; 0x7aa <main+0x1fc>

00000ce6 <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
  TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
 ce6:	8c e0       	ldi	r24, 0x0C	; 12
 ce8:	80 b9       	out	0x00, r24	; 0
// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
  TWDR = 0xFF;                                      // Default content = SDA released.
 cea:	8f ef       	ldi	r24, 0xFF	; 255
 cec:	83 b9       	out	0x03, r24	; 3
  TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
 cee:	84 e0       	ldi	r24, 0x04	; 4
 cf0:	86 bf       	out	0x36, r24	; 54
         (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
         (0<<TWWC);                                 //
}    
 cf2:	08 95       	ret

00000cf4 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
 cf4:	86 b7       	in	r24, 0x36	; 54
}
 cf6:	81 70       	andi	r24, 0x01	; 1
 cf8:	08 95       	ret

00000cfa <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
 cfa:	06 b6       	in	r0, 0x36	; 54
 cfc:	00 fc       	sbrc	r0, 0
 cfe:	fd cf       	rjmp	.-6      	; 0xcfa <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
 d00:	80 91 75 00 	lds	r24, 0x0075
 d04:	08 95       	ret

00000d06 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
 d06:	fc 01       	movw	r30, r24
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 d08:	06 b6       	in	r0, 0x36	; 54
 d0a:	00 fc       	sbrc	r0, 0
 d0c:	fd cf       	rjmp	.-6      	; 0xd08 <TWI_Start_Transceiver_With_Data+0x2>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
 d0e:	60 93 c2 00 	sts	0x00C2, r22
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
 d12:	80 81       	ld	r24, Z
 d14:	80 93 ba 00 	sts	0x00BA, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
 d18:	80 fd       	sbrc	r24, 0
 d1a:	11 c0       	rjmp	.+34     	; 0xd3e <TWI_Start_Transceiver_With_Data+0x38>
  {
    for ( temp = 1; temp < msgSize; temp++ )
 d1c:	62 30       	cpi	r22, 0x02	; 2
 d1e:	78 f0       	brcs	.+30     	; 0xd3e <TWI_Start_Transceiver_With_Data+0x38>
 d20:	df 01       	movw	r26, r30
 d22:	eb eb       	ldi	r30, 0xBB	; 187
 d24:	f0 e0       	ldi	r31, 0x00	; 0
 d26:	62 50       	subi	r22, 0x02	; 2
 d28:	70 e0       	ldi	r23, 0x00	; 0
 d2a:	64 54       	subi	r22, 0x44	; 68
 d2c:	7f 4f       	sbci	r23, 0xFF	; 255
      TWI_buf[ temp ] = msg[ temp ];
 d2e:	11 96       	adiw	r26, 0x01	; 1
 d30:	8c 91       	ld	r24, X
 d32:	11 97       	sbiw	r26, 0x01	; 1
 d34:	81 93       	st	Z+, r24
 d36:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
 d38:	e6 17       	cp	r30, r22
 d3a:	f7 07       	cpc	r31, r23
 d3c:	c1 f7       	brne	.-16     	; 0xd2e <TWI_Start_Transceiver_With_Data+0x28>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
 d3e:	10 92 b8 00 	sts	0x00B8, r1
  TWI_state         = TWI_NO_STATE ;
 d42:	88 ef       	ldi	r24, 0xF8	; 248
 d44:	80 93 75 00 	sts	0x0075, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 d48:	85 ea       	ldi	r24, 0xA5	; 165
 d4a:	86 bf       	out	0x36, r24	; 54
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
 d4c:	08 95       	ret

00000d4e <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 d4e:	06 b6       	in	r0, 0x36	; 54
 d50:	00 fc       	sbrc	r0, 0
 d52:	fd cf       	rjmp	.-6      	; 0xd4e <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
 d54:	10 92 b8 00 	sts	0x00B8, r1
  TWI_state         = TWI_NO_STATE ;
 d58:	88 ef       	ldi	r24, 0xF8	; 248
 d5a:	80 93 75 00 	sts	0x0075, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 d5e:	85 ea       	ldi	r24, 0xA5	; 165
 d60:	86 bf       	out	0x36, r24	; 54
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
 d62:	08 95       	ret

00000d64 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
 d64:	ac 01       	movw	r20, r24
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 d66:	06 b6       	in	r0, 0x36	; 54
 d68:	00 fc       	sbrc	r0, 0
 d6a:	fd cf       	rjmp	.-6      	; 0xd66 <TWI_Get_Data_From_Transceiver+0x2>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
 d6c:	80 91 b8 00 	lds	r24, 0x00B8
 d70:	80 ff       	sbrs	r24, 0
 d72:	12 c0       	rjmp	.+36     	; 0xd98 <TWI_Get_Data_From_Transceiver+0x34>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 d74:	66 23       	and	r22, r22
 d76:	81 f0       	breq	.+32     	; 0xd98 <TWI_Get_Data_From_Transceiver+0x34>
 d78:	20 e0       	ldi	r18, 0x00	; 0
 d7a:	30 e0       	ldi	r19, 0x00	; 0
    {
      msg[ i ] = TWI_buf[ i ];
 d7c:	fa 01       	movw	r30, r20
 d7e:	e2 0f       	add	r30, r18
 d80:	f3 1f       	adc	r31, r19
 d82:	d9 01       	movw	r26, r18
 d84:	a6 54       	subi	r26, 0x46	; 70
 d86:	bf 4f       	sbci	r27, 0xFF	; 255
 d88:	8c 91       	ld	r24, X
 d8a:	80 83       	st	Z, r24
 d8c:	2f 5f       	subi	r18, 0xFF	; 255
 d8e:	3f 4f       	sbci	r19, 0xFF	; 255

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 d90:	26 17       	cp	r18, r22
 d92:	a0 f3       	brcs	.-24     	; 0xd7c <TWI_Get_Data_From_Transceiver+0x18>
 d94:	80 91 b8 00 	lds	r24, 0x00B8
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
}
 d98:	81 70       	andi	r24, 0x01	; 1
 d9a:	08 95       	ret

00000d9c <__vector_17>:
application.
****************************************************************************/
//#pragma vector=TWI_vect
//__interrupt void TWI_ISR(void)
ISR(TWI_vect)
{
 d9c:	1f 92       	push	r1
 d9e:	0f 92       	push	r0
 da0:	0f b6       	in	r0, 0x3f	; 63
 da2:	0f 92       	push	r0
 da4:	11 24       	eor	r1, r1
 da6:	2f 93       	push	r18
 da8:	3f 93       	push	r19
 daa:	8f 93       	push	r24
 dac:	9f 93       	push	r25
 dae:	af 93       	push	r26
 db0:	bf 93       	push	r27
 db2:	ef 93       	push	r30
 db4:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 db6:	81 b1       	in	r24, 0x01	; 1
 db8:	90 e0       	ldi	r25, 0x00	; 0
 dba:	fc 01       	movw	r30, r24
 dbc:	38 97       	sbiw	r30, 0x08	; 8
 dbe:	e1 35       	cpi	r30, 0x51	; 81
 dc0:	f1 05       	cpc	r31, r1
 dc2:	90 f0       	brcs	.+36     	; 0xde8 <__vector_17+0x4c>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 dc4:	81 b1       	in	r24, 0x01	; 1
 dc6:	80 93 75 00 	sts	0x0075, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 dca:	84 e0       	ldi	r24, 0x04	; 4
 dcc:	86 bf       	out	0x36, r24	; 54
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 dce:	ff 91       	pop	r31
 dd0:	ef 91       	pop	r30
 dd2:	bf 91       	pop	r27
 dd4:	af 91       	pop	r26
 dd6:	9f 91       	pop	r25
 dd8:	8f 91       	pop	r24
 dda:	3f 91       	pop	r19
 ddc:	2f 91       	pop	r18
 dde:	0f 90       	pop	r0
 de0:	0f be       	out	0x3f, r0	; 63
 de2:	0f 90       	pop	r0
 de4:	1f 90       	pop	r1
 de6:	18 95       	reti
//__interrupt void TWI_ISR(void)
ISR(TWI_vect)
{
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 de8:	ed 5e       	subi	r30, 0xED	; 237
 dea:	ff 4f       	sbci	r31, 0xFF	; 255
 dec:	09 94       	ijmp
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 dee:	10 92 b9 00 	sts	0x00B9, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 df2:	90 91 b9 00 	lds	r25, 0x00B9
 df6:	80 91 c2 00 	lds	r24, 0x00C2
 dfa:	98 17       	cp	r25, r24
 dfc:	98 f4       	brcc	.+38     	; 0xe24 <__vector_17+0x88>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 dfe:	e9 2f       	mov	r30, r25
 e00:	f0 e0       	ldi	r31, 0x00	; 0
 e02:	e6 54       	subi	r30, 0x46	; 70
 e04:	ff 4f       	sbci	r31, 0xFF	; 255
 e06:	80 81       	ld	r24, Z
 e08:	83 b9       	out	0x03, r24	; 3
 e0a:	9f 5f       	subi	r25, 0xFF	; 255
 e0c:	90 93 b9 00 	sts	0x00B9, r25
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 e10:	85 e8       	ldi	r24, 0x85	; 133
 e12:	86 bf       	out	0x36, r24	; 54
 e14:	dc cf       	rjmp	.-72     	; 0xdce <__vector_17+0x32>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 e16:	83 b1       	in	r24, 0x03	; 3
 e18:	e0 91 b9 00 	lds	r30, 0x00B9
 e1c:	f0 e0       	ldi	r31, 0x00	; 0
 e1e:	e6 54       	subi	r30, 0x46	; 70
 e20:	ff 4f       	sbci	r31, 0xFF	; 255
 e22:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 e24:	80 91 b8 00 	lds	r24, 0x00B8
 e28:	81 60       	ori	r24, 0x01	; 1
 e2a:	80 93 b8 00 	sts	0x00B8, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 e2e:	84 e9       	ldi	r24, 0x94	; 148
 e30:	86 bf       	out	0x36, r24	; 54
 e32:	cd cf       	rjmp	.-102    	; 0xdce <__vector_17+0x32>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 e34:	85 ea       	ldi	r24, 0xA5	; 165
 e36:	86 bf       	out	0x36, r24	; 54
 e38:	ca cf       	rjmp	.-108    	; 0xdce <__vector_17+0x32>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 e3a:	20 91 b9 00 	lds	r18, 0x00B9
 e3e:	83 b1       	in	r24, 0x03	; 3
 e40:	e2 2f       	mov	r30, r18
 e42:	f0 e0       	ldi	r31, 0x00	; 0
 e44:	e6 54       	subi	r30, 0x46	; 70
 e46:	ff 4f       	sbci	r31, 0xFF	; 255
 e48:	80 83       	st	Z, r24
 e4a:	2f 5f       	subi	r18, 0xFF	; 255
 e4c:	20 93 b9 00 	sts	0x00B9, r18
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 e50:	30 e0       	ldi	r19, 0x00	; 0
 e52:	80 91 c2 00 	lds	r24, 0x00C2
 e56:	90 e0       	ldi	r25, 0x00	; 0
 e58:	01 97       	sbiw	r24, 0x01	; 1
 e5a:	28 17       	cp	r18, r24
 e5c:	39 07       	cpc	r19, r25
 e5e:	34 f4       	brge	.+12     	; 0xe6c <__vector_17+0xd0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 e60:	85 ec       	ldi	r24, 0xC5	; 197
 e62:	86 bf       	out	0x36, r24	; 54
 e64:	b4 cf       	rjmp	.-152    	; 0xdce <__vector_17+0x32>
 e66:	20 91 b9 00 	lds	r18, 0x00B9
 e6a:	f2 cf       	rjmp	.-28     	; 0xe50 <__vector_17+0xb4>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 e6c:	85 e8       	ldi	r24, 0x85	; 133
 e6e:	86 bf       	out	0x36, r24	; 54
 e70:	ae cf       	rjmp	.-164    	; 0xdce <__vector_17+0x32>

00000e72 <_exit>:
 e72:	f8 94       	cli

00000e74 <__stop_program>:
 e74:	ff cf       	rjmp	.-2      	; 0xe74 <__stop_program>
